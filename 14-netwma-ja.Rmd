# ネットワークメタ分析 {#netwma}

---

<img src="_figs/network.jpg" />

<br></br>

<span class="firstcharacter">臨</span>
床試験や他の種類の介入研究のメタ分析を行う場合、通常、**1**個の特定の治療の真の効果の大きさを推定する。我々は、同じ種類の介入を同様の対照群、例えばプラセボと比較した研究を含める。他の条件がすべて同じであれば、これは**特定の**種類の治療が効果的かどうかを評価することを可能にする。

しかし、多くの研究分野では、「決定的な」治療法は一つだけではなく、いくつもあるのである。例えば、片頭痛はいろいろな薬物療法があるし、非薬物療法の選択肢もある。特に「成熟した」研究分野では、ある種の治療が有効であることを示すことは、あまり意味がないことが多いのである。むしろ、ある特定の適応症に対して、どの治療法が**最も**効果的であるかを調べたいのである。

これは新たな問題を引き起こす。従来のメタ分析で複数の治療の比較有効性を評価するためには、2つの治療間の直接比較が十分存在していることが必要である。しかし、残念なことに、そうではないこともよくある。多くの研究分野では、「弱い」対照群の代わりに、2つの治療の効果を**直接**比較した臨床試験は、一般にあったとしても少ない。このことは、従来のメタ分析では、複数の治療法の**相対的**な有効性に関する確かな証拠を確立できないことを意味することが多い。

しかし、2つ以上の治療法を直接比較することはできなくとも、**間接的**な証拠は通常利用可能である。異なる治療法が**別々の**試験で評価されたとしても、これらの試験はすべて**同じ**対照群を用いている可能性がある。例えば、直接比較されたことはない2種類の薬があるとしても、それぞれの効果がプラセボと比較して研究されている可能性がある。

\index{Mixed-Treatment Comparison Meta-Analysis}

**ネットワークメタ分析** (network meta-analysis) では、このような間接的な比較を取り入れ、複数の介入の効果を同時に比較することがが可能である [@dias2013evidence]。ネットワークメタ分析は、**混合治療比較メタ分析** (mixed-treatment comparison meta-analysis) としても知られている [@van2012automating]。これは、複数の直接的・間接的な治療比較を1つのモデルに統合し、比較の「ネットワーク」として形式化することができるからである。

\index{Consistency}

ネットワークメタ分析は「ホット」な研究トピックである。この10年間で、バイオ分野・メディカル分野やその他の分野の応用研究者によって取り上げられることが増えてきた。しかし、この方法には、異質性やいわゆる**ネットワークの矛盾** (network inconsistency) に関する、通常のメタ分析以上に課題や落とし穴もある [@salanti2014evaluating]。

したがって、まずネットワークメタ分析モデルの中核的な構成要素と前提について議論することが重要である。ネットワークメタ分析の基礎は、少し抽象的になることがある。そこで、この手法の理解を深めるために、本質的な内容を少しずつ見ていこう。

<br></br>

## ネットワークメタ分析とは何か? {#what-is-net-ma}

---

### 直接証拠と間接証拠 {#direct-indirect-evidence}

---

まず、治療の「ネットワーク」とは何を意味するのかを理解する必要がある。ある無作為化比較試験 $i$ からデータを抽出し、治療Aの効果を他の条件B（例えば、待機リスト対照群）と比較したとする。この比較を図式化することができる。


```{r, message = F, out.width = '75%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/graph1_col_sep.png')
```

\index{Graph Theory}\index{グラフ理論}

このように治療法の比較を視覚的に表現したものを**グラフ**と呼ぶ。グラフは、異なるオブジェクトが互いにどのように関連しているかをモデル化するために使用される構造であり、このトピックに関する数学の分野として、**グラフ理論**が存在する。

このグラフには2つの主要な構成要素がある。一つは、試行 $i$ における二つの条件AとBを表す二つの円(いわゆる**ノード**)である。2つ目は、この2つのノードを結ぶ線である。この線は**エッジ**と呼ばれる。エッジは、AとBがどのように関係するかを表す。私たちの場合、この線の解釈は非常に簡単である。AとBを比較したときに観測される効果の大きさ $\theta_{i\text{,A,B}}$ でAとBの関係を表すことが可能である。この効果の大きさは、例えば、結果の指標によって標準化平均差（SMD）やオッズ比などで表現することが可能である。

さて、別の試験 $j$ からもデータを得たとする。この試験でも対照条件Bを用いたが、Aを投与する代わりに別の治療法Cを用いた。

```{r, message = F, out.width = '75%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/graph2_col_sep.png')
```

これで最初の小さなネットワークができあがる。グラフに2つの効果量推定値が含まれていることがよくわかる。A と B を比較した $\hat\theta_{i\text{,A,B}}$ と、C と B を比較した $\hat\theta_{j\text{,C,B}}$ である。これらの効果量は両方とも「実際の」試験で直接観察されているので、我々はその情報を**直接的証拠**と呼んでいる。したがって、これらの効果量を $\hat\theta^{\text{direct}}_{\text{B,A}}$ と $\hat\theta^{\text{direct}}_{\text{B,C}}$ で表記する。この表記で条件 B が最初に来るのは、**基準**グループと決めたからである。B を参照条件としたのは、両試験で対照群として用いられていたからである。

新しいグラフでは、すべてのノード（条件）は、**直接的**か、**間接的**に接続されている。B 条件（対照群）は、他のすべてのノードに直接接続されている。B から他の2つのノード A、C に行くには、グラフ上で1つの「ステップ」しか必要ない：B $\rightarrow$ A, B $\rightarrow$ C。 一方、A と C は1つの直接接続しかなく、両方とも B に接続する：A $\rightarrow$ B と C $\rightarrow$ B。

しかし、A と C の間には間接的なつながりがある。このつながりは、B が2つの条件  A $\rightarrow$ B と C $\rightarrow$ B の間のリンク、すなわち**ブリッジ**として機能するために存在する。その結果、ネットワークの構造から導き出される A と C の関係の**間接的な証拠**が存在する。


```{r, message = F, out.width = '75%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/graph3_col_sep.png')
```

直接観測されたエッジの情報を使って、**間接的に**観測されたAとCの比較の効果を計算することが可能である。この非観測、間接効果量を $\hat\theta^{\text{indirect}}_{\text{A,C}}$ と表記する。効果推定値は、次の式を用いて導出できる。 [@dias2018network, chapter 1]:

\begin{equation}
\hat\theta_{\text{A,C}}^{\text{indirect}} = \hat\theta_{\text{B,A}}^{\text{direct}} - \hat\theta_{\text{B,C}}^{\text{direct}}
(\#eq:networkes)
\end{equation}

このステップは、ネットワークメタ分析の重要な要素である。上記の式は、たとえそれが試験で直接評価されなかったとしても、比較の効果量を推定することが可能である。

ネットワークメタ分析では、1つのモデルで直接および間接的なエビデンスを組み合わせる。この情報に基づいて、含まれる各治療の（相対）効果を推定することが可能である。間接的な証拠を追加することで、その特定の比較に直接的な証拠がある場合でも、効果量推定の精度を上げることが可能である。全体として、ネットワークメタ分析にはいくつかの利点がある。

* 関連する一連の研究から入手可能なすべての情報を1つの分析にプールすることができる。従来のメタ分析で、例えばプラセボと異なる治療法を比較する試験をどのように扱うかを考えてみてみよう。それぞれの比較（例えば、治療Aとプラセボの比較、治療Bとプラセボの比較、治療Aと治療Bの比較など）を別々のメタ分析でプールしなければならないだろう。

* ネットワークメタ分析では、従来のメタ分析では不可能であった間接的なエビデンスをネットワークに取り込むことが可能である。ペアワイズメタ分析では、実際に試験に含まれた比較のうち、直接的な証拠のみをプールすることができる。

* すべての仮定が満たされ、結果が十分に決定的であれば、ネットワークメタ分析によって、研究対象集団に対してどのタイプの治療が望ましいかを推論することができる。

これらはすべて興味深いものであるが、考慮すべき重要な限界がいくつかある。まず、間接効果量の推定値の分散がどのように計算されるかを見てみよう。

\begin{equation}
\text{Var} \left(\hat\theta_{\text{A,C}}^{\text{indirect}} \right) = \text{Var} \left(\hat\theta_{\text{B,A}}^{\text{direct}} \right) + \text{Var} \left(\hat\theta_{\text{B,C}}^{\text{direct}} \right)
(\#eq:nw2)
\end{equation}

間接比較の分散を計算するために、直接比較の分散を **足し算** した。つまり、間接的な証拠から推定される効果量は、直接的な証拠に基づくものよりも常に大きな分散を持ち、したがって精度も低くなる [@dias2018network, Chapter 1]。これは極めて論理的である。数学的に推測しなければならない結果に比べ、観測データから推定された効果量には、はるかに高い信頼性を持つことができるのである。 

\index{Consistency}
\index{Transitivity Assumption}\index{推移性仮定}

さらにもう1つの問題がある。直接比較から間接的な証拠を推定することができる先ほどの式 \@ref(eq:networkes) は、重要な前提条件である**推移性 (transivity)** の仮定が満たされた場合にのみ成立するのである。統計学的な観点からは、この仮定はネットワークの**一貫性 (consistency)** と訳される [@efthimiou2016getreal]。以下では、この2つの用語の意味と、それらがなぜ重要であるかを説明する。

<br></br>

### 推移性と一貫性 {#transivity-consistency}

---

ネットワークメタ分析は、標準的なメタ分析手法の延長線上にある貴重な手法であるのは間違いない。しかし、その有効性には疑問が残る。ネットワークメタ分析に対する批判の多くは、推察される通り、間接的な証拠の利用を中心に展開されている [@edwards2009indirect; @ioannidis2006indirect]。これは特に、比較のために直接証拠が実際に利用可能である場合を含んでいる。

（ランダム化）試験の参加者は治療条件（例えば A と B）のいずれかに**偶然**割り当てられるが、私たちのネットワークでは試験条件そのものはランダムに選択されていないという点は重要である。もちろん、これはすべて論理的なことである。通常、被験者をいくつかの試験条件のうちの1つにランダムに割り当てることは問題ない。しかし、研究者がサイコロを振って治験の治療条件を決めてから研究を展開することは考えにくい。ネットワークメタ分析では、選択された試験条件の構成がランダムなパターンになることはほとんどない。

これはネットワークメタ分析モデル自体の問題ではない [@dias2018network, Chapter 1]。ネットワークメタ分析モデルが偏るのは、試験内の特定の比較の選択、または非選択が、その比較の真の効果に依存する場合のみである [@dias2013evidence]。この表現はかなり抽象的なので、少し詳しく説明しよう。

\index{Consistency}
\index{Transitivity Assumption}\index{推移性仮定}

今述べた要件は、ネットワークメタ分析の**推移性**という仮定から導かれたものである。これがネットワークメタ分析に特有の仮定なのか、それとも従来の pairwise メタ分析の仮定を単に拡張したものなのかについては、文献上でも意見が分かれているようである。また、この意見の相違は、文献における用語の一貫性のない使い方にも一部起因している可能性がある [@dias2018network; @efthimiou2016getreal; @song2009methodological; @lu2009modeling]。

推移性の仮定の核となる考え方は、以前、式 \@ref(eq:networkes) [@efthimiou2016getreal] を用いて行ったように、（例えば比較 A $-$ B と C $-$ Bから）直接証拠を組み合わせて、関連する比較（例えば A $-$ C）について間接証拠を作り出せることである。

\index{Exchangeability Assumption}

推移性の仮定は**交換性**の概念と関係している。この前提条件については、ランダム効果モデルについて説明した Chapter \@ref(rem) で既に述べた。交換可能性の仮定は、ある比較 $i$ のそれぞれの真の効果量 $\theta_i$ は、真の効果量の「包括的」分布からランダムに、**独立**に引き出された結果であることを言う。

この仮定を私たちのシナリオに置き換えると、ネットワークメタ分析は、$K$ 件の臨床試験のセットと考える。ここで、このモデルの各試験は、$M$ で示されるネットワークでの**すべての**治療比較を含むと仮定する（たとえば、A $-$ B, A $-$ C, B $-$ C, など）。しかし、いくつかの臨床試験では、治療比較が**"削除"**され、**"欠落"**しているものがある。その理由は、実際には、研究はすべての可能な治療法の選択肢を評価することはできないからである [@dias2013evidence]。

重要な前提としては、ある比較、例えば A $-$ B の効果は、試験間で**交換可能**であり、ある試験が実際にこの比較を評価したか、それが 「欠落」しているかは関係ない、ということである。ネットワークメタ分析では、ある比較 $i$ の効果 $\hat\theta_i$ が、効果量が直接または間接的な証拠によって得られたとしても、真の効果の包括的な分布からのランダムで独立した抽選に基づくとき、交換性が満たされる。

共変量や他の効果修飾因子（調査集団の年齢層や治療強度など）が、例えば、条件 A 対 B、C 対 B を評価する試験間で均等に分布していない場合、推移性の仮定が破られる可能性がある [@song2009methodological]。推移性を統計的に検証することはできませんが、母集団、方法論、対象条件ができるだけ類似している試験のみを含めることで、この仮定に違反するリスクを軽減することがが可能である [@salanti2014evaluating]。

統計的な推移性の現れ方を**整合** (consistency) と言い、その欠如を**不整合** (inconsistency) と言う [@efthimiou2016getreal; @cipriani2013conceptual]。整合とは、直接証拠に基づく比較（例：A $-$ B）と間接証拠に基づく比較の相対的効果が異ならないことを意味する [@schwarzer2015meta, chapter 8]。
 
\begin{equation}
\theta_{\text{A,B}}^{\text{indirect}} = \theta_{\text{A,B}}^{\text{direct}}
(\#eq:nw3)
\end{equation}

\vspace{4mm}

\index{Node Splitting}

ネットワークメタ分析モデルの不整合を診断する方法として、**net heat plots** [@krahn2013graphical] や **node splitting** method [@dias2010checking] など、いくつかの方法が提案されている。これらの方法については、以下のセクションで詳しく説明する。

<br></br>

### ネットワークメタ分析のモデル {#netw-which-model}

---

以上で、ネットワークメタ分析モデルの基本的な理論と前提条件についての説明を終える。以前は、3つのノードとエッジを持つ単純なネットワークを説明として使用していた。しかし、実際には、ネットワークメタ分析に含まれる治療法の数は、通常、はるかに多くなる。そのため、すぐにかなり複雑なネットワークになり、例えば次のようなネットワークになる。

\vspace{4mm}

```{r, message = F, out.width = '75%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/graph4_col_sep.png')
```

しかし、ネットワーク内の治療法 $S$ の数が増えれば、推定しなければならない（直接・間接）一対比較 $C$ の数は急増する。

\vspace{4mm}

```{r, message=F, warning=F, fig.width=4, fig.height=3, out.width="45%", fig.align="center", echo=F}
library(ggplot2)

C <- function(S){S*((S-1)/2)}


ggplot(data = data.frame(x = 0), mapping = aes(x = x)) + 
  stat_function(fun = C, cex = 1) + xlim(0,20) + theme_classic() +
  annotate("text", label = expression(C == S~frac((S-1),2)), x = 6, y = 150) +
  xlab("Number of treatments/conditions in network (S)") +
  ylab("Number of comparisons (C)") +
  theme(plot.background = element_rect(fill = "#FFFEFA", color = "#fbfbfb"),
        panel.background = element_rect(fill = "#FFFEFA"))

```

\vspace{4mm}

\index{Frequentist Statistics}\index{頻度主義統計学}
\index{Bayesian Hierarchical Model}

したがって、効率的かつ内部的に一貫性のある方法で、利用可能なすべてのネットワークデータをプールできる計算モデルが必要である。ネットワークメタ分析のために、いくつかの統計的アプローチが開発されている [@efthimiou2016getreal]。以下の章では、**頻度論的階層モデル** (frequentist hierarchical model) と**ベイズ階層モデル** (Bayesian hierarchical model) について説明し、それらがどのように _R_ に実装され得るかを説明する。

```{block, type='boxinfo'}
**どのモデル手法を使うべきか？**

\vspace{2mm}

複数のネットワークメタ分析モデルがある場合、それぞれの統計手法が異なることもありうる。良いことにサンプルサイズが十分であれば、どれも同じ結果を出すはずである [@shim2019network]。一般的に、ネットワークメタ分析の方法は、他の方法よりも有効であるとか、有効でなかったりすることはない。そのため、直感的に選ぶか、またはそれを実装している _R_ パッケージの機能に基づいて、どちらかの方法を安全に選択することがが可能である [@efthimiou2016getreal]。

\vspace{2mm}

ほとんどの分野では、ベイズ的アプローチよりも頻度論的推論に基づく手法の方が（今でも）ずっと一般的である。これは、人によっては、頻度論的モデルが生み出す結果をより簡単に理解することができるためかもしれない。頻度論的モデルのデメリットとしては、 _R_ における頻度論的ネットワークメタ分析の実装（次に取り上げる）では、ベイズモデルで可能なメタ回帰がまだサポートされていないことが挙げられる。

\vspace{2mm}

実際には、メインの分析に1つのアプローチを選択し、感度分析でもう1つのアプローチを採用するのが有効な戦略である。2つの手法が同じ結論に至れば、その知見が信頼に足るものであるという確信が得られる。

```

<br></br>

## 頻度論的ネットワークメタ分析 {#frequentist-ma}

---

\index{netmeta Package}
\index{Frequentist Statistics}\index{頻度主義統計学}

以下では、**{netmeta}** パッケージ [@nemeta]  を用いたネットワークメタ分析の実行方法を説明する。このパッケージは、**頻度論的** (frequentist) 枠組みでネットワークメタ分析モデルを推定することが可能である。**{netmeta}** で使用されている手法は、もともと電気ネットワーク用に開発されたグラフ理論的手法から派生したものである [@rucker2012network]。

```{block, type='boxinfo'}
**確率の頻度論的解釈**

\vspace{2mm}

頻度論的とは、ある事象 $E$ の確率を解釈するための一般的な理論的アプローチである。頻出論的アプローチは、あるプロセス（例えば実験）を**何度も何度も**繰り返した場合に$E$ が発生すると予想される頻度で $E$ の確率を定義する [@aronow2019foundations, chapter 1.1.1]。

頻度論的な考え方は、定量的な研究者が日常的に使う多くの統計処理、例えば有意性検定、信頼区間の計算、$p$ 値の計算などの核心となるものである。

```

<br></br>

### グラフ理論モデル

---

ここで、**{netmeta}** パッケージで実装されているネットワークメタ分析モデルがどのように定式化されるかを説明しよう。いくつかの臨床試験から効果量のデータを集めたとする。そして、$K$ 件すべての試験を調べて、試験に含まれる治療比較の総数を数える。この対の比較の数を $M$ 件とする。

そして、各比較 $m$ に対する効果量 $\hat\theta_m$ を計算し、全ての効果量をベクトル $\boldsymbol{\hat\theta} = (\hat\theta_1, \hat\theta_2, \dots, \hat\theta_M)$  に集める。ネットワークメタ分析を行うには、この観測された効果量のベクトル $\boldsymbol{\hat\theta}$ がどのように生成されたかを記述するモデルが必要である。**{netmeta}**では、以下のようなモデルを用いる [@schwarzer2015meta, Chapter 8]。

\begin{equation}
\boldsymbol{\hat\theta} =\boldsymbol{X} \boldsymbol{\theta}_{\text{treat}} + \boldsymbol{\epsilon} 
(\#eq:nw4)
\end{equation}

観測された効果の大きさのベクトル $\boldsymbol{\hat\theta}$ は、式の右辺（私たちのモデル）によって生成されたと仮定する。前段の $\boldsymbol{X}$ は $m \times n$ **デザイン行列**で、列は異なる治療法 $n$、行は治療比較 $m$ を表している。この行列では、治療比較は同じ行の1と-1で定義され、列の位置は比較される治療と対応する。

式の最も重要な部分は、ベクトル $\boldsymbol{\theta}_{\text{treat}}$ である。このベクトルは、ネットワーク内の $n$ 個のユニークな治療の**真の** 効果を含みる。このベクトルは、ネットワークメタ分析モデルが推定する必要があるもので、ネットワーク内のどの治療が最も効果的であるかを決定することを可能にするからである。

パラメータ $\boldsymbol{\epsilon}$ は、すべての比較のサンプリング誤差$\epsilon_m$を含むベクトルである。各比較のサンプリング誤差は、平均0、分散$\sigma^2_m$のガウス正規分布から無作為抽出であると仮定する。

\begin{equation}
\epsilon_m \sim \mathcal{N}(0,\sigma_m^2)
(\#eq:nw4)
\end{equation}

モデル式を説明するために [@schwarzer2015meta, page 189参照]、私たちのネットワークメタ分析が $K=$ 5 件の研究から構成されていると想像する。各研究は、ユニークな治療比較を含む（すなわち、$K=M$）。これらの比較は、A $-$ B, A $-$ C, A $-$ D, B $-$ C, および B $-$ Dである。この結果、（観測された）比較のベクトルは $\boldsymbol{\hat\theta} = (\hat\theta_{1\text{,A,B}}, \hat\theta_{2\text{,A,C}}, \hat\theta_{4\text{,A,D}}, \hat\theta_{4\text{,B,C}}, \hat\theta_{5\text{,B,D}})^\top$。 私たちの目的は、ネットワークに含まれる4つの条件全ての真の効果量、$\boldsymbol{\theta}_{\text{treat}} = (\theta_{\text{A}}, \theta_{\text{B}}, \theta_{\text{C}}, \theta_{\text{D}})^\top$ を推定することである。これらのパラメータをモデルの式に代入すると、次のような式が得られる。

\begin{align}
  \boldsymbol{\hat\theta} &= \boldsymbol{X} \boldsymbol{\theta}_{\text{treat}} + \boldsymbol{\epsilon} \notag \\
 \begin{bmatrix}
 \hat\theta_{1\text{,A,B}} \\
 \hat\theta_{2\text{,A,C}} \\
 \hat\theta_{3\text{,A,D}} \\
 \hat\theta_{4\text{,B,C}} \\
 \hat\theta_{5\text{,B,D}} \\
 \end{bmatrix}
 &=
 \begin{bmatrix}
 1 & -1 & 0 & 0 \\
 1 & 0 & -1 & 0 \\
 1 & 0 & 0 & -1 \\
 0 & 1 & -1 & 0 \\
 0 & 1 & 0 & -1 \\
 \end{bmatrix}
 \begin{bmatrix}
 \theta_{\text{A}} \\
 \theta_{\text{B}} \\
 \theta_{\text{C}} \\
 \theta_{\text{D}} \\
 \end{bmatrix}
 +
 \begin{bmatrix}
 \epsilon_{1} \\
 \epsilon_{2} \\
 \epsilon_{3} \\
 \epsilon_{4} \\
 \epsilon_{5} \\
 \end{bmatrix}
 (\#eq:nw5)
\end{align}


なお、このモデル式は、現在のままでは数学的な観点から問題がある。今のところ、このモデルは**overparameterized**である。手元の情報に基づいて推定するには、私たちのモデルにはあまりにも多くのパラメータ $\boldsymbol{\theta}_{\text{treat}}$ が存在する。

これは、デザイン行列 $\boldsymbol{X}$ が**フルランク**でないことと関係がある。我々の場合、行列は、その列がすべて**独立**でないとき、フルランクを持たない。または、別の言い方をすると、**独立**列の数が列の**総数** $n$ より小さいとき、フルランクを持たない ^[行列の行数が列数より少ない場合（$m < n$）、独立した**行**の数が行の総数 $m$ より小さいと、行列はフルランクではない。] 。治療の**ネットワーク**を扱っているので、治療の組み合わせが互いに完全に独立でないことは明らかである。例えば、治療Dの列（4列目）は、最初の3列の**線形結合**として記述することができる ^[最初の3列（治療法 A、B、C）に-1を掛けて足すと、4列目の値が得られる $(-\boldsymbol{x}_1) + (-\boldsymbol{x}_2) + (-\boldsymbol{x}_3) = \boldsymbol{x}_4$。] 。

全体として、たかだか $n-1$ 個の独立した治療比較が存在することになるが、私たちのモデルは常に $\boldsymbol{\theta}_{\text{treat}}$ の $n$ 個の治療の真の効果を推定しなければならない。したがって、この行列はフルランクではない。このように $\boldsymbol{X}$ がフルランクを持たないということは、**invertible**ではないということである。したがって、$\boldsymbol{\theta}_{\text{treat}}$ は（加重）最小二乗法を使って直接推定することができないのである。

\index{Graph Theory}\index{グラフ理論}

そこで、**{netmeta}** に実装されている**グラフ理論**のアプローチが解決策を提供する。このアプローチの背後にある退屈な数学的詳細については、**{netmeta}** パッケージが作業をこなしてくれるので、ここでは割愛する。この方法は、いわゆる **Moore-Penrose 擬似逆行列**を構築し、重み付き最小二乗法を用いてネットワークモデルの適合値を計算することができる、ということだけを述べておく。

この手順では、2つ以上のペアワイズ比較（つまり、2つ以上の条件が比較された研究）を行う**マルチアーム**（訳注：arm は群と同じ意味）研究についても考慮する。マルチアーム比較は、少なくとも1つの条件が2回以上比較されるため、**相関**がある (Chapter \@ref(unit-of-analysis))。このことは、このモデルで説明しない限り、マルチアーム試験の比較の精度が人為的に高くなることを意味する。

また、このモデルでは、試験間の異質性 (heterogeneity) の推定値を組み込むことができる。「従来の」ランダム効果モデル（Chapter \@ref(rem)）と同様に、比較 $m$ の分散に推定異質性分散 $\hat\tau^2$ を追加することで実現する。すなわち $s^2_m + \hat\tau^2$ である。**{netmeta}**パッケージでは、DerSimonian-Laird estimator 法  [@jackson2013matrix, Chapter \@ref(tau-estimators) も参照] を適応して$\tau^2$値を推定している。


\index{Consistency}

$I^2$ に相当するものも計算でき、これでネットワーク内の**不整合** (inconsistency) の量を表すことができる。この $I^2$ は、Higgins and Thompson の式と同様に、$Q$ から導かれる。ただし、ネットワークメタ分析では、$Q$ は**ネットワーク**の総異質性に変換される（$Q_{\text{total}}$とも表記される）。したがって、以下の式が使われる。

\begin{equation}
I^2 = \text{max} \left(\frac{Q_{\text{total}}-\text{d.f.}} {Q_{\text{total}}}, 0 \right) 
(\#eq:nw6)
\end{equation}

ここで、ネットワークの自由度は:

\begin{equation}
\text{d.f.} = \left( \sum^K_{k=1}p_k-1 \right)- (n-1)
(\#eq:nw7)
\end{equation}

とし、$K$ を研究の総数、$p$ をある研究 $k$ における条件の数、$n$ をネットワークモデルにおける治療の総数とする。

<br></br>

###  _R_ での頻度論的ネットワークメタ分析

---

ここまでインプットしたら、いよいよ実践的な例題である。以下では、**{netmeta}** を使って、独自のネットワークメタ分析を行う。いつものように、まずパッケージをインストールし、それからライブラリからロードする。

```{r, message=F, warning=F}
library(netmeta)
```

<br></br>

#### データを準備

---

この図では、`TherapyFormats` データを使用している。このデータセットは、うつ病に対する認知行動療法の異なる提供形式の有効性を評価する実際のネットワークメタ分析 [@cuijpers2019effectiveness] をモデルとしている。含まれるすべての研究は、うつ病の症状に対する効果がテスト後に測定されたランダム化比較試験である。含まれる比較の効果量は、分析された2つの条件間の標準化平均差（SMD）として表現されている。

\index{dmetar Package}

```{block, type='boxdmetar'}
**"TherapyFormats" データセット**

\vspace{2mm}

`TherapyFormats` データセットは **{dmetar}** パッケージに含まれている。**{dmetar}** をインストールし、ライブラリからロードした後、 `data(TherapyFormats)` を実行すると、自動的に _R_ 環境にデータセットが保存される。これでデータセットが使用できるようになる。

\vspace{2mm}

**{dmetar}** がインストールされていない場合は、[インターネット](https://www.protectlab.org/meta-analysis-in-r/data/TherapyFormats.rda) から _.rda_ ファイルとしてデータセットをダウンロードし、作業ディレクトリに保存してから、R Studio ウィンドウでクリックしてインポートすることが可能である。

```


データを見てみよう。

```{r, message=F, warning=F}
library(dmetar)
data(TherapyFormats)

head(TherapyFormats[1:5])
```

* 2列目の `TE` には、すべての比較の効果量、そして `seTE` にはそれぞれの標準誤差が格納される。**{netmeta}** を使用するには、データセット内の全ての効果量が既に計算されている必要がある。効果量の計算方法については、Chapter \@ref(effects) で説明したが、Chapter \@ref(es-calc) の章では、さらに詳しい計算方法を紹介している。

* このデータセットには、さらに2つの列がある。このデータセットには、さらに2つの列が含まれているが、ここでは示していない。これらの列には、単純に条件のフルネームが格納されている。

* `studlab` 列は、特定の治療比較がどの研究から抽出されたかを示す、ユニークな研究ラベルを含んでいる。この列は、マルチアーム研究（すなわち、複数の比較対象がある研究）をチェックするのに便利である。これは、 `table` と `as.matrix` 関数を使用して行うことが可能である。

```{r, eval=F}
as.matrix(table(TherapyFormats$author))
```

```
## [...]
## Bengston, 2004              1
## Blevins, 2003               1
## Bond, 1988                  1
## Bonertz, 2015               1
## Breiman, 2001               3
## [...]
```

`TherapyFormats`のデータセットには、Breiman によるマルチアーム研究1件しか含まれていない。この研究には3つの比較が含まれているが、他の研究は1つしか含まれていない。

ネットワークメタ分析のデータを作成する際には、（1）データセットに研究ラベルの列を含めること、（2）その列で個々の研究に固有の名前を付けること、（3）2つ以上の比較に貢献する研究には**正確に**同じ名前を付けることが不可欠となる。

<br></br>

#### モデルを適合

---

`netmeta` 関数を使って、最初のネットワークメタ分析モデルを適合させることが可能である。最も重要な引数は以下の通りである。

* **`TE`**. 各比較の効果量を含むデータセットの列の名前である。

* **`seTE`**. 各比較の標準誤差を格納する列の名前。

* **`treat1`**.	データセット中の **最初の** 処置の名前を格納する列。

* **`treat2`**.	データセット中の **`treat2`** の列には、**2番目の** 処置の名前が含まれている。

* **`studlab`**.	比較対象が抽出された研究。この引数はオプションであるが、常に指定することを勧める。この引数は任意であるが、常に指定することを推奨する。これは、私たちのネットワークにマルチアーム試験がある場合に、この関数に知らせる唯一の方法である。

* **`data`**. データセットの名前である。

* **`sm`**. 使用する効果量の種類。`"RD"`（リスク差）、`"RR"`（リスク比）、`"OR"`（オッズ比）、`"HR"`（ハザード比）、`"MD"`（平均差）、 `"SMD"` （標準化平均差）などとすることができる。その他の利用可能な指標については、関数ドキュメント (`?netmeta`) を参照。

* **`fixed`**.	固定効果ネットワークメタ分析を行うかどうか？`TRUE` または `FALSE` を指定する必要がある。

* **`random`**.	ランダム効果モデルを用いるか？`TRUE` または `FALSE`。

* **`reference.group`**.	他の全ての治療に対して、どの治療を参照治療とするか（例： `reference.group = "grp"` ） を指定することが可能である。

* **`tol.multiarm`**.	 マルチアーム研究の比較の効果量は、デザイン上、一貫している。しかし、原著論文では、各比較でわずかにずれた結果が報告されていることがあり、その結果、整合性が損なわれていることがある。この引数で、効果量とその標準誤差の矛盾に対する**許容閾値**（数値）を指定することで、モデルで許容される。

* **`details.chkmultiarm`**.	効果量の不一致があるマルチアーム比較の推定値を表示するかどうか (`TRUE` または `FALSE`).

* **`sep.trts`**. 比較ラベルのセパレーターとして使用する文字（例：`" vs. "`）。

最初のネットワークメタ分析の結果は、`m.netmeta`という名前で保存される。参照グループとして、"care as usual" (`"cau"`) 条件を使用する。今は、固定効果モデルが適切であると仮定しよう。この場合、次のようなコードになる。

\vspace{2mm}

```{r, eval=F}
m.netmeta <- netmeta(TE = TE,
                     seTE = seTE,
                     treat1 = treat1,
                     treat2 = treat2,
                     studlab = author,
                     data = TherapyFormats,
                     sm = "SMD",
                     fixed = TRUE,
                     random = FALSE,
                     reference.group = "cau",
                     details.chkmultiarm = TRUE,
                     sep.trts = " vs ")
summary(m.netmeta)
```

```
## Original data (with adjusted standard errors for multi-arm studies):
## 
##                    treat1 treat2    TE seTE seTE.adj narms multiarm
## [...]
## Burgan, 2012          ind    tel -0.31 0.13   0.1390     2         
## Belk, 1986            ind    tel -0.17 0.08   0.0830     2         
## Ledbetter, 1984       ind    tel -0.00 0.23   0.2310     2         
## Narum, 1986           ind    tel  0.03 0.33   0.3380     2         
## Breiman, 2001         ind    wlc -0.75 0.51   0.6267     3        *
## [...]
## 
## Number of treatment arms (by study):
##                          narms
## Ausbun, 1997                 2
## Crable, 1986                 2
## Thiede, 2011                 2
## Bonertz, 2015                2
## Joy, 2002                    2
## [...]
## 
## Results (fixed effects model):
## 
##                treat1 treat2   SMD         95%-CI      Q leverage
## Ausbun, 1997      grp    ind  0.06 [ 0.00;  0.12]   0.64     0.03
## Crable, 1986      grp    ind  0.06 [ 0.00;  0.12]   3.05     0.01
## Thiede, 2011      grp    ind  0.06 [ 0.00;  0.12]   0.05     0.03
## Bonertz, 2015     grp    ind  0.06 [ 0.00;  0.12]   0.01     0.01
## Joy, 2002         grp    ind  0.06 [ 0.00;  0.12]   0.02     0.00
## [....]
## 
## Number of studies: k = 182
## Number of treatments: n = 7
## Number of pairwise comparisons: m = 184
## Number of designs: d = 17
## 
## Fixed effects model
## 
## Treatment estimate (sm = 'SMD', comparison: other treatments vs 'cau'):
##         SMD             95%-CI      z  p-value
## cau       .                  .      .        .
## grp -0.5767 [-0.6310; -0.5224] -20.81 < 0.0001
## gsh -0.3940 [-0.4588; -0.3292] -11.92 < 0.0001
## ind -0.6403 [-0.6890; -0.5915] -25.74 < 0.0001
## tel -0.5134 [-0.6078; -0.4190] -10.65 < 0.0001
## ush -0.1294 [-0.2149; -0.0439]  -2.97   0.0030
## wlc  0.2584 [ 0.2011;  0.3157]   8.84 < 0.0001
##
## 
## Quantifying heterogeneity / inconsistency:
## tau^2 = 0.26; tau = 0.51; I^2 = 89.6% [88.3%; 90.7%]
## 
## Tests of heterogeneity (within designs) and inconsistency (between designs):
##                       Q d.f.  p-value
## Total           1696.84  177 < 0.0001
## Within designs  1595.02  165 < 0.0001
## Between designs  101.83   12 < 0.0001
```

この出力には見るべきものがたくさんあるので、順を追って見ていこう。最初に見るのは、各比較の計算された効果量である。アスタリスク記号（*）は、標準誤差が（効果量の依存性を考慮し）修正された私たちのマルチアーム研究を示している。その下には、各研究の治療群の数の概要が示されている。

次の表は、私たちの（固定効果）ネットワーク・メタ分析モデルにおける各比較の適合値を示している。この表の $Q$ 列は、どの比較がネットワーク全体の不整合に大きく寄与しているかを示しており、とても興味深い。例えば、Crable, 1986 の $Q$ 値は $Q=$ 3.05 で、かなり高いことがわかる。

そして、ネットワークメタ分析の核心である「治療推定値」にたどり着く。指定されたように、すべての治療の効果は、通常通りのケアとの比較で表示されているが、それが `cau` の効果が表示されていない理由である。その下に、このネットワークモデルにおける異質性/非整合性が非常に高く、$I^2=$ 89.6%であることを見ることができる。これは、固定効果モデルの選択がおそらく適切では**なかった**ことを示している（この点については後ほど触れる）。

\index{Consistency}
\index{Heterogeneity}\index{異質性}

出力の最後の部分（`Tests of heterogeneity`）は、ネットワークにおける総異質性を、2つのコンポーネントに分解している。すなわち、**デザイン内**の異質性、および**デザイン間**の不一致である。「デザイン」とは、例えばA $-$ B、A $-$ B $-$ Cのように、1つの試験に含まれる条件の選択と定義される。全く同じ条件を含む試験間で真の効果量の差がある場合、デザイン内異質性と呼ぶことができる。一方、デザイン間のばらつきは、私たちのネットワークの矛盾を反映している。デザイン内異質性、デザイン間不整合性ともに非常に有意である（$p$s < 0.001）。

これは、ランダム効果モデルが指示されている可能性を示すもう一つのサインである。これをさらに裏付けるために、**full design-by-treatment interaction random-effects model** [@higgins2012consistency] に基づくtotal inconsistencyを算出することが可能である。これを行うには、`m.netmeta`オブジェクトを`decomp.design`関数に差し込めばよいのである。

\vspace{2mm}

```{r, eval=F}
decomp.design(m.netmeta)
```

```
## Q statistics to assess homogeneity / consistency
##  [...]
## Design-specific decomposition of within-designs Q statistic
## 
##      Design      Q df  p-value
##  cau vs grp   82.5 20 < 0.0001
##  cau vs gsh    0.7  7   0.9982
##  cau vs ind  100.0 29 < 0.0001
##  cau vs tel   11.4  5   0.0440
##  [...]
## 
## Between-designs Q statistic after detaching of single designs
## 
##    Detached design      Q df  p-value
##  [...]
##         ind vs wlc  77.23 11 < 0.0001
##         tel vs wlc  95.45 11 < 0.0001
##         ush vs wlc  95.81 11 < 0.0001
##  gsh vs ind vs wlc 101.78 10 < 0.0001
##
## Q statistic to assess consistency under the assumption of
## a full design-by-treatment interaction random effects model
## 
##                    Q df p-value tau.within tau2.within
## Between designs 3.82 12  0.9865     0.5403      0.2919
```

\index{Cochran's \textit{Q}}

出力では、まず、このモデルにおけるデザイン内およびデザイン間の異質性/非整合性に対する各デザインの個々の寄与を示す $Q$ 値が示される。出力の重要な部分は、最後の部分（`Q statistic to assess consistency under the assumption of a full design-by-treatment interaction random effects model`）である。完全な design-by-treatment のランダム効果モデルを仮定すると、$Q$ の値がかなり減少し（以前は $Q=$ 101.83、今は $Q=$ 3.83）、デザイン間の矛盾が有意でなくなったことがわかる（$p=$ 0.9865）。 

このことは、私たちのネットワークモデルにおける矛盾や異質性を説明するために、少なくとも部分的にランダム効果モデルが示される可能性をも示唆している。


<br></br>

#### ネットワークモデルのさらなる検証

---

##### ネットワークグラフ

---

\index{Network Graph}

`netmeta` を使ってネットワークメタ分析モデルをフィットさせた後、**ネットワークグラフ** を作成することができる。これは `netgraph` 関数を用いて行うことが可能である。`netgraph` 関数には多くの引数があり、コンソールで `?netgraph` を実行すれば調べることができる。しかし、これらの引数のほとんどは、非常に賢明なデフォルト値を持っているので、あまり多くのことを指定する必要はない。

最初のステップとして、フィットしたモデル `m.netmeta` を関数に与えてみる。モデルでは短縮ラベルを使用しているので、プロットでは長いラベル（`treat1.long` と `treat2.long` に格納）に置き換える必要がある。これは、 `labels` 引数を用いて行うことができ、すべての治療法の完全な名前を指定する必要がある。治療ラベルは、 `m.netmeta$trts` に格納されているものと同じ順序である必要がある。

\vspace{4mm}

```{r, echo=F}
load("data/m.netmeta.rda")
```

```{r}
# 治療順序を表示（短いラベル）
m.netmeta$trts
```


```{r, message=F, warning=F, eval=F}
# フルネームを置き換え（see treat1.long と treat2.long を参照）
long.labels <- c("Care As Usual", "Group", 
                 "Guided Self-Help", 
                 "Individual", "Telephone", 
                 "Unguided Self-Help", 
                 "Waitlist")

netgraph(m.netmeta, 
         labels = long.labels)
```

```{r, message=F, warning=F, echo=F, fig.width=7, fig.height=7, echo=F, fig.align='center', out.width="55%"}

# Replace with full name (see treat1.long and treat2.long)
long.labels <- c("Care As Usual", "Group", "Guided \n Self-Help", 
                 "Individual", "Telephone", 
                 "Unguided \n Self-Help", "Waitlist")

par(bg="#FFFEFA")
# Produce the plot
netgraph(m.netmeta, labels = long.labels, col.multiarm = "lightgray", offset = 0.03, cex = 1.5)

long.labels <- c("Care As Usual", "Group", "Guided Self-Help", 
                 "Individual", "Telephone", 
                 "Unguided Self-Help", "Waitlist")
```

このネットワークグラフはいくつかの種類の情報を運ぶ。まず、我々はネットワークにおける比較の全体的な構造を見ることが可能である。これは、元のデータでどの治療が互いに比較されたかをよりよく理解することが可能である。

さらに、プロット中のエッジが異なる**幅**を持っていることがわかる。幅の大きさは、ネットワークで特定の比較を見つける頻度を表している。例えば、ガイド付きセルフヘルプのフォーマットは、多くの試験で待機リストと比較されていることがわかる。また、網掛けされた三角形で表現されたマルチアーム試験も見られる。これはBreimanによる研究で、ガイド付き自己啓発、個人セラピー、待機者リストの3つを比較したものである。

`netgraph`関数は、**3Dグラフ**を描くこともでき、複雑なネットワーク構造をよりよく把握するのに便利である。この関数は、**{rgl}**パッケージがインストールされ、ロードされていることが必要である。3Dグラフを作成するためには、`dim` 引数を `"3d"` に設定するだけである。

```{r, eval=F}
library(rgl)
netgraph(m.netmeta, dim = "3d")
```

<br></br>

##### 直接証拠と間接証拠の可視化

---

次のステップでは、各比較を推定するために使用される**direct**と**indirect**の証拠の比率を見よう。**{dmetar}** の `direct.evidence.plot` 関数は、この目的のために開発された関数である。

\index{dmetar Package}

```{block, type='boxdmetar'}
**"direct.evidence.plot" 関数**

\vspace{4mm}

`direct.evidence.plot` 関数は、**{dmetar}** パッケージに含まれている。**{dmetar}** がインストールされ、コンピュータに読み込まれると、この関数を使用できるようになる。もし、**{dmetar}** をインストールして**いない**場合は、以下の手順でインストールできる。

1. 関数のソースコードにアクセスする [オンライン](https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/power.analysis.subgroup.R). 
2. ソースコード全体をコンソール（R Studio の左下ペイン）にコピー＆ペーストし、Enterキーを押して、 _R_ に関数を「学習」させる。
3. **{ggplot2}** と **{gridExtra}** パッケージがインストールされ、ロードされていることを確認する。

```


この関数は、各推定比較に使用された直接証拠と間接証拠のパーセンテージを示すプロットを提供する。`direct.evidence.plot`関数が入力として必要とするのは、フィットしたネットワークメタ分析モデル `m.netmeta`のみである。

\vspace{2mm}

```{r, message=F, warning=F, fig.width=8, fig.height=5, fig.align='center', out.width="75%", eval=F}
library(dmetar)

d.evidence <- direct.evidence.plot(m.netmeta)
plot(d.evidence)
```


```{r, message=F, warning=F, fig.width=8, fig.height=5, fig.align='center', out.width="75%", echo=F}
library(dmetar)
# source("data/direct.evidence.plot.bw.R")

d.evidence <- dmetar::direct.evidence.plot(m.netmeta)
plot(d.evidence)
```

\index{Mean Path Length}
\index{Minimal Parallelism}

\vspace{2mm}

見てわかるように、このネットワークモデルには、間接的な証拠だけで推論しなければならない推定値がいくつかあることがわかる。また、このプロットでは、各推定比較の**最小並列度**と**平均パス長**という2つの追加指標を得ることが可能である。König, Krahn, and Binder [-@konig2013visualizing] によると、平均パス長 > 2 であるとは、比較推定が特に注意して解釈されるべきことを意味する。

<br></br>

##### 効果推計表

---

次に、すべての可能な治療比較について、私たちのネットワークの推定値を見ることができる。これを行うには、 `m.netmeta$TE.fixed` （固定効果モデルを使用した場合）または `m.netmeta$TE.random` （ランダム効果モデルを使用した場合）に保存された行列を使用することで可能である。行列を読みやすくするために、いくつかの前処理をしておこう。まず、`m.netmeta`オブジェクトからデータを抽出し、行列の数値を小数点以下2桁に丸める。

```{r}
result.matrix <- m.netmeta$TE.fixed
result.matrix <- round(result.matrix, 2)
```

行列の1つの「三角形」が冗長な情報を持つことを考慮して、このコードを使って下の三角形を空の値に置き換える。

```{r}
result.matrix[lower.tri(result.matrix, diag = FALSE)] <- NA
```

これにより、次のような結果が得られる。

```{r}
result.matrix
```

これらの結果を研究論文で報告する場合、各効果量の推定値の信頼区間を含める方がよいだろう。これは、 `m.netmeta` の `lower.fixed` と `upper.fixed` （または `lower.random` と `upper.random` ）行列を使用して、以前と同じ方法で取得することが可能である。

さらに便利な方法は、 `netleague` 関数を使用して、すべての推定効果量をエクスポートすることである。この関数は、上で作成したものと同じような表を作成する。しかし、`netleague`によって生成された行列では、上部の三角形は、私たちのネットワークで利用可能な**直接比較**のプール効果量のみを表示し、我々がそれぞれの比較について従来のメタ分析を行った場合のようなものを達成することが可能である。我々はすべての比較について直接の証拠を持っているわけではないので、上側の三角形のいくつかのフィールドは空のままである。`netleague` が生成する行列の下側の三角形には、**それぞれ**比較の推定効果量が含まれる（間接的な証拠しか得られないものも含まれる）。

`netleague` の出力は、簡単に.csv ファイルにエクスポートすることが可能である。これは、ネットワークメタ分析の包括的な結果を1つの表で報告するために使用することが可能である。この関数を使用するもう一つの大きな利点は、効果量推定値と信頼区間が各セルに一緒に表示されることである。このような治療推定表を作成して、"netleague.csv" という名前の .csv ファイルとして保存したい。これは、以下のコードを用いて実現が可能である。

```{r}
# Produce effect table
netleague <- netleague(m.netmeta, 
                       bracket = "(", # use round brackets
                       digits=2)      # round to two digits

# Save results (here: the ones of the fixed-effect model)
write.csv(netleague$fixed, "netleague.csv")
```


<br></br>

##### 治療法のランキング

---

\index{Surface Under the Cumulative Ranking (SUCRA) Score}
\index{P-Score}

ネットワークメタ分析で答えられる最も興味深い問題は、どの治療が最も高い効果を持つかということである。**{netmeta}** に実装された `netrank` 関数は、この点で役に立つ。これは、治療の**ランキング**を生成することができ、どの治療が最大の効果をもたらす可能性が高いか低いかを示す。

`netrank` 関数は、`netmeta` 自体で使われているモデルと同様に、頻度論的アプローチに基づいている。この頻度論的手法は、治療の順位付けに **P-score** を使用している。これは、ある治療が他の治療よりも優れているという確実性を、すべての競合する治療に対して平均して測定するものである。P-スコアは、ベイズネットワークメタ分析の章で説明する **SUCRA** スコア[@rucker2015ranking]と同等であることが示されている。

`netrank` 関数は入力として `m.netmeta` というモデルを必要とする。さらに、`small.values` パラメータを指定する必要がある。これは、比較において小さい（つまり、負の）効果量が有益（`"good"`）または有害（`"bad"`）の効果を示しているかを定義するものである。ここでは、`small.values = "good"`を使用する。つまり、効果量が負であるとき、ある治療法が**うつ病を減少させる**のに有効であることを意味する。

```{r}
netrank(m.netmeta, small.values = "good")
```

個人セラピー（`ind`）のPスコアが最も高く、この治療形式が特に有用であることを示している。逆に、待機者リスト（`wlc`）のPスコアはゼロである。これは、単に治療を待たせることは最良の選択肢ではないという直感と一致しているようである。

とはいえ、ランキング[@mbuagbaw2017approaches]で最高スコアだからといって、ある治療法が「最善」であると自動的に結論づけるべきでは決してないだろう。このネットワークにおける**不確実性**をよりよく可視化する方法は、ある条件を比較群として使用したフォレストプロットを作成することである。

\index{Forest Plot}\index{フォレストプロット}

**{netmeta}** では、`forest` 関数を使用してこれを実現することができる。**{netmeta}**の `forest` 関数の動作は、Chapter \@ref(forest) で説明した **{meta}** パッケージの `forest` 関数と非常によく似ている。主な違いは、forestプロットで参照グループを `reference.group` 引数で指定する必要があることである。また、care us usual (`"cau"`) を使用する。

\vspace{4mm}

```{r, fig.width=6, fig.height=4, out.width="80%", fig.align='center'}
forest(m.netmeta, 
       reference.group = "cau",
       sortvar = TE,
       xlim = c(-1.3, 0.5),
       smlab = paste("Therapy Formats vs. Care As Usual \n",
                     "(Depressive Symptoms)"),
       drop.reference.group = TRUE,
       label.left = "Favors Intervention",
       label.right = "Favors Care As Usual",
       labels = long.labels)
```

\vspace{4mm}

フォレストプロットでは、個人療法以外にも高いパフォーマンスを示す治療形式があることがわかる。また、信頼区間の一部が重なっていることもわかる。このため、明確な判断は容易ではない。個別治療が最も良い結果を出しているように見えるが、いくつかの治療法も通常のケアと比較して大きな効果を上げている。


<br></br>

#### 結果の妥当性を評価

---


##### ネットヒートプロット {#net-heat-plot}

---

**{netmeta}** パッケージは `netheat` という関数を内蔵しており、これにより **ネットヒートプロット** を作成することが可能である。ネットヒートプロットは、ネットワークモデルの不整合や、どのようなデザインが不整合に寄与しているかを評価するのに非常に有効である。

`netheat` 関数は、フィットしたネットワークメタ分析オブジェクトを必要とするだけで、プロットを生成する。

```{r, fig.width=5, fig.height=5, eval=F}
netheat(m.netmeta)
```

```{r, message = F, out.width = '60%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/heat_fixed_col_sep.png')
```

この関数は、行の各デザインが他のデザイン（列）と比較される2次ヒートマップを生成する。重要な点は、行と列が、このネットワークにおける個々の治療**比較**ではなく、特定の**デザイン**を意味することである。したがって、このプロットは、マルチアーム研究で使用されたデザイン（ガイド付き自助、個人療法、待機者リストの比較）の行と列も特徴としている。ネットヒートプロットには2つの重要な特徴がある[@schwarzer2015meta, chapter 8]。

\index{Consistency}

* **灰色のボックス**。灰色のボックスは、ある治療比較が他の治療比較の推定にどれだけ重要であるかを示すものである。ボックスが大きければ大きいほど、その比較はより重要である。これを分析する簡単な方法は、プロットの行を次々に見ていき、各行でどのボックスが最も大きいかをチェックすることである。よくある発見は、ヒートマップの対角線上にあるボックスが大きいことである。これは、直接証拠が使われたことを意味するからである。例えば、特に大きなボックスは、 "cau vs grp" 行と "cau vs grp" 列の交点で見ることが可能である。

* **色のついた背景**。色のついた背景は、**行**のデザインが**列**のデザインに起因する**不整合**の量を意味する。フィールドの色は、深い赤（強い矛盾を示す）から青（このデザインからの証拠が行の証拠をサポートすることを示す）までの範囲となる。`netheat` 関数は、アルゴリズムを使用して、行と列を矛盾が大きいクラスタと小さいクラスタにソートする。このプロットでは、いくつかの矛盾したフィールドが左上隅に表示されている。例えば、"ind vs wlc" の行では、"cau vs grp" の列のエントリーが赤く表示されていることが分かる。これは、"ind vs wlc" の推定に対して "cau vs grp" が寄与しているエビデンスが矛盾していることを意味する。一方、"gsh vs wlc" 列のフィールドは濃い青色で表示されており、これはこのデザインの証拠が行デザイン "ind vs wlc" の証拠を**サポート**していることを表している。

この結果は、固定効果モデルを用いてネットワークメタ分析モデルを適合させたため、固定効果モデルに基づいていることを再認識する必要がある。しかし、これまでの研究から、固定効果モデルの使用は適切ではないことが次第に明らかになってきた--異質性とデザインの矛盾が多すぎるのである。

そこで、ランダム効果モデルを仮定したときに、ネットヒートプロットがどのように変化するかを確認してみよう。`netheat` の `random` 引数を `TRUE` に設定することにより、これを行うことが可能である。

```{r, fig.width=5, fig.height=5, eval=F}
netheat(m.netmeta, random = TRUE)
```

```{r, message = F, out.width = '60%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/heat_random_col_sep.png')
```

この結果、ネットワーク内の不整合が大幅に減少していることがわかる。暗赤色の背景を持つフィールドはなくなった。これは、ランダム効果モデルが使用されると、私たちのモデルの全体的な一貫性がかなり改善されることを示している。

したがって、私たちのデータには、ランダム効果モデルが望ましいと結論づけることが可能である。実際には、`netmeta`を使用して `comb.random` を `TRUE` に設定しながら（そして `comb.fixed` を `FALSE` に設定して）モデルを再実行し、ランダム効果モデルに基づく分析結果のみを報告することになる。また、ランダム効果モデルに基づく分析結果のみを報告する。

<br></br>

##### ネット分割化 {#net-splitting}

---

\index{Node Splitting}

私たちのネットワークの一貫性をチェックするもう1つの方法は、**ネット分割化**である。この方法は、私たちのネットワーク推定を直接証拠と間接証拠の寄与に分割し、私たちのネットワーク内の個々の比較の推定における矛盾をコントロールすることを可能にするものである。ネット分割手法を適用するには、適合したモデルで `netsplit` 関数を提供するだけでよい。


```{r, eval=F}
netsplit(m.netmeta)
```

```
## Separate indirect from direct evidence using back-calculation method
## 
## Fixed effects model: 
## 
##  comparison  k prop     nma  direct  indir.    Diff     z  p-value
##  grp vs cau 21 0.58 -0.5767 -0.3727 -0.8628  0.4901  8.72 < 0.0001
##  gsh vs cau  8 0.22 -0.3940 -0.5684 -0.3442 -0.2243 -2.82   0.0048
##  ind vs cau 30 0.71 -0.6403 -0.7037 -0.4863 -0.2174 -3.97 < 0.0001
##  tel vs cau  6 0.35 -0.5134 -0.7471 -0.3867 -0.3604 -3.57   0.0004
##  ush vs cau  9 0.35 -0.1294 -0.1919 -0.0953 -0.0966 -1.06   0.2903
##  [...]
## 
## Legend:
##  [...]
##  Diff       - Difference between direct and indirect estimates
##  z          - z-value of test for disagreement (direct vs. indirect)
##  p-value    - p-value of test for disagreement (direct vs. indirect)
```

出力で示される最も重要な情報は、直接的証拠と間接的証拠に基づく効果推定値の差（`Diff`）と、この差が有意であるかどうか（`p-value`列で示される）である。差が$p<$ 0.05のとき、直接推定と間接推定の間に有意な不一致（不整合）があることになる。

出力では、（固定効果モデルを使用した場合）直接証拠と間接証拠の間に有意な不一致を示す比較が確かにたくさんあることがわかる。正味の分割結果を可視化する良い方法は、フォレストプロットである。

```{r, fig.width=7, fig.height=17, fig.align='center', out.width="79%"}
netsplit(m.netmeta) %>% forest()
```

<br></br>

##### 比較調整済みファネルプロット

---

\index{Funnel Plot}\index{ファンネルプロット}

ネットワークメタ分析モデルで出版バイアスを評価することは困難である。Chapter \@ref(pub-bias) で紹介した手法の多くは、従来のメタ分析からネットワークメタ分析へ移行すると、そのまま適用することはできない。しかし、ネットワークメタ分析における出版バイアスのリスクを評価するために、**比較調整ファンネルプロット**が提案されており、特定の条件下では使用することがが可能である [@salanti2014evaluating]。このファンネルプロットは、出版バイアスがネットワークモデルにどのような影響を与えたかに関する**特定の**仮説がある場合に適用される。

例えば、サンプルサイズが小さくても、「新規」の知見を持つ研究は出版される可能性が高いので、出版バイアスが生じる可能性がある。科学には、「画期的な」結果を出そうとする自然な動機がある。例えば、新しいタイプの治療法が現在の技術水準よりも優れていることを示すためである。

ということは、今回のデータには small-study effect（Chapter \@ref(small-study-effects) 参照）のようなものが存在することになる。新しい治療法と古い治療法を比較した場合の効果は、ファネルプロットにおいて**非対称**に分布していることが予想される。これは、「期待はずれ」の結果（つまり、新しい治療法が古い治療法より優れていない）が、ファイルの引き出しに入るからである。サンプルサイズが小さくなるにつれて、新しい治療法の有益性は、有意になるためにますます大きくなり、したがって、出版に値するようになる必要がある。理論的には、これは標準的なメタ分析で見られる特徴的な非対称のファンネルプロットを作成することになる。

もちろん、このようなパターンは、プロット内の効果量がある方法でコード化されている場合にのみ現れる。例えば、「新旧仮説」を検証するためには、プロットで使用される各効果量が同じように解釈できることを確認する必要がある。例えば、正の効果量は常に「新しい」治療が優れていたことを示し、負の符号はその反対を意味することを確認する必要がある。これは、古い治療法から新しい治療法への「ランキング」を定義し、このランキングを使用して各効果の符号を定義することで実現が可能である。

**{netmeta}**の `funnel` 関数は、このような比較調整されたファネルプロットを生成するために使用することが可能である。以下は最も重要な引数である。

* **`order`**.	この引数は、仮説とされる出版バイアスメカニズムの順序を指定する。我々は、単にネットワーク内のすべての治療名を提供し、私たちの仮説に従ってそれらをソートする必要がある。たとえば、出版バイアスが「新しい」治療を好むかどうかを検証したい場合、すべての治療名を挿入し、最も古い治療から始めて、最も新しいタイプの介入で終了する。

* **`pch`**. これは、ファネルプロットで使用する研究のシンボルを指定するものである。`19`に設定すると、例えば単純なドットが表示される。

* **`col`**.	この引数を使用すると、異なる比較を区別するために使用する色を指定することが可能である。ここで指定する色の数は、ファネルプロットにおける **ユニーク** な比較の数と同じでなければならない。実際には、これは多くの異なる色が必要であることを意味する。 _R_ がプロットに使用できる色の完全なリストは、[オンライン](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf)で見ることが可能である。

* **`linreg`**.	TRUE` に設定すると、ファネルプロットの非対称性に対する Egger の検定 (Chapter \@ref(eggers-test)) が行われ、その $p$ 値がプロット内に表示される。

引数は **{meta}** の `funnel` 関数に定義されているものを追加で使用することも可能である。


```{r, fig.width=7, fig.height=5, eval=F}
funnel(m.netmeta, 
      order = c("wlc", "cau", "ind", "grp", # from old to new
                "tel", "ush", "gsh"), 
      pch = c(1:4, 5, 6, 8, 15:19, 21:24), 
      col = c("blue", "red", "purple", "forestgreen", "grey", 
              "green", "black", "brown", "orange", "pink", 
              "khaki", "plum", "aquamarine", "sandybrown", 
              "coral", "gold4"), 
      linreg = TRUE)
```

```{r, fig.width=9, fig.height=7, fig.align='center', out.width="78%", echo=F}
par(bg="#FFFEFA")
funnel(m.netmeta, 
      order = c("wlc", "cau", # from old to new
                "ind", "grp", "tel", 
                "ush", "gsh"), 
      pch = c(1:4, 5, 6, 8, 15:19, 21:24), 
      col = c("blue", "red", "purple", "forestgreen", "grey", 
              "green", "black", "brown", "orange", "pink", 
              "khaki", "plum", "aquamarine", "sandybrown", 
              "coral", "gold4"), 
      linreg = TRUE)
```

もし仮説が正しければ、サンプルサイズが小さい（つまり標準誤差が大きい）研究は、プロットのゼロ線付近に非対称に分布すると予想される。これは、新しい治療法と古い治療法を比較し、新しい治療法が優れていないことを発見した小規模の研究は、出版される可能性が低いからである。したがって、これらの研究は漏斗の片側で系統的に欠落しているのである。

しかし、このプロットは極めて対称的に見える。これは Egger の検定で確認されたが、有意ではないであった（$p=$ 0.402）。全体として、これは私たちのネットワークに小規模研究の効果があることを示すものではない。少なくとも、優れた効果を持つ「革新的な」治療法は、発表された文献の中に見つかる可能性が高いからである。

```{block, type='boxinfo'}
**{netmeta} を使ったネットワークメタ分析：最後の要点**

\vspace{2mm}

この章は長い章であり、新しいトピックを大量にカバーしてきた。**{netmeta}** で使われている統計モデルの背後にあるコアなアイデアを示し、このアプローチでネットワークメタ分析モデルを適合させる方法、結果を可視化し解釈する方法、そして発見の妥当性を評価する方法について説明した。ネットワークメタ分析における（臨床）意思決定は、1つのテストやメトリックに基づくべきでないことは、どれほど強調しても十分とはいえない。

その代わりに、私たちは素直な目でモデルとその結果を探求し、見つけたパターンの一貫性をチェックし、推定値に関連する大きな不確実性を考慮に入れなければならないのである。

\vspace{2mm}

次章では、ベイズの観点からネットワークメタ分析を（再び）考えてみる。このアプローチの背後にある哲学は、ここで説明したものとかなり異なるが、どちらの手法も本質的に同じことを達成しようとするものである。実際、解析の「パイプライン」も驚くほど似ている。さあ、ベイズ解析の時間だ。

```

<br></br>

## ベイズ的ネットワークメタ分析 {#bayesian-net-ma}

---

以下では、ベイズ型階層構造フレームワークに基づくネットワークメタ分析の実行方法を説明する。このために使用する _R_ パッケージは、**{gemtc}** [@van2012automating]と呼ばれるものである。しかし、その前に、一般的なベイズ推論の考え方と、ネットワークメタ分析に使用できるベイズモデルの種類を考えてみよう。


<br></br>

### ベイズ推論 {#bayesian-inference}

---

\index{Bayes' Theorem}
\index{Frequentist Statistics}\index{頻度主義統計学}
\index{Conditional Probability}

ベイズ推定は、頻度論的 (frequentist) 統計学とは別に、重要な統計学である。頻度論的統計学は、ほとんどの研究分野でより頻繁に使用されていると言ってよいでしょう。しかし、ベイズアプローチの方が実は古く、近年は研究者に取り上げられることが多くなっており [@marsman2017bayesian]、決して「無くなった」わけではない [@mcgrayne2011theory]。

ベイズ統計学の基礎となるのは、トーマス・ベイズ牧師 [1701-1761、@bellhouse2004reverend] が最初に定式化した**ベイズの定理**である。ベイズ統計学が頻出主義と異なるのは、「主観的」な**事前**知識も取り入れて推論を行う点である。ベイズの定理は、ある事象Aが発生する確率を、別の事象Bが発生したことを既に知っていると仮定して推定することを可能にする。これは、**条件付き確率**と呼ばれ、$P(\text{A}|\text{B})$ のように表現される。この定理は、この条件付き確率の計算方法を説明する公式に基づいている。

\begin{equation}
P(\text{A}|\text{B})=\frac{P(\text{B}|\text{A})\times P(\text{A})}{P(\text{B})}
(\#eq:nw8)
\end{equation}

\index{Posterior Distribution}
\index{Prior Distribution}

この式では、分数の分子にある2つの確率にそれぞれ名前がついている。$P(\text{B}|\text{A})$  の部分は、**尤度**（ゆうど）と呼ばれる。Aがある場合に事象Bが発生する確率である [@etz2018introduction]。$P(\text{A})$ は、$A$ が発生する**先行**確率である。$P(\text{A}|\text{B})$ は、**posterior** 確率で、B が与えられたときの A の確率である。

\begin{equation}
P(\text{A}|\text{B}) \propto P(\text{B}|\text{A})\times P(\text{A})
(\#eq:nw9)
\end{equation}


ここで、$\propto$ という記号は、分数の分母を捨てたので、値が変化しても、左側の確率は右側の部分と少なくとも**比例**していることを意味している。

ベイズの定理は、上の式の右辺から順に考えていくと理解しやすい。Aの確率に関する事前情報と、Aが起こる場合のBの可能性を組み合わせて、Aの事後確率（適応確率） $P(\text{A}|\text{B})$ を出すだけなのである。ここで重要なのは、前の知識を考慮すると、Aの確率の「より良い」（事後）推定値が得られるということである。この知識は、Aの確率を仮定したもの（事前確率）である。

ベイズの定理は、AやBを特定の事象に見立てて、先ほどの方法で説明されることが多いようである。しかし、AやBを2つの変数の**確率分布**と考えることもが可能である。Aを正規分布に従う確率変数とする。この分布は、パラメータの集合で特徴付けることができ、それを $\boldsymbol{\theta}$ で表す。Aは正規分布なので、 $\boldsymbol{\theta}$ にはAの真の平均 $\mu$ と分散 $\sigma^2$ の2つの要素が含まれている。

さらに、Bについて、$\boldsymbol{\theta}$ の推定に使いたい**実測データ**を集めたとする。観測されたデータをベクトル $\boldsymbol{Y}$ に格納する。また、観測データは正規分布に従うので、$P({Y})$ で表される。このことから、次のような式が成り立つ。

\begin{equation}
P(\boldsymbol{\theta} | {\boldsymbol{Y}} ) \propto P( {\boldsymbol{Y}} | \boldsymbol{\theta} )\times P( \boldsymbol{\theta})
(\#eq:bayes)
\end{equation}

\index{Credible Interval}

この式には、$P(\boldsymbol{\theta})$ という $\boldsymbol{\theta}$ の事前分布を仮定している。この事前分布は、これまでの知識に基づいて、あるいは直感的に $\boldsymbol{\theta}$ がどのようなものであるかを、私たちが _a priori_ に定義することが可能である。尤度分布 $P({\boldsymbol{Y}}|\boldsymbol{\theta})$ と、パラメータ $\boldsymbol{\theta}$ が与えられたときのデータの確率 $P(\boldsymbol{\theta}|{\boldsymbol{Y}})$ から、事後分布を推定することができる。この事後分布は、観測データと事前知識の両方を考慮した場合の $\boldsymbol{\theta}$ の推定値を表している。

\index{Credible Interval}

重要なのは、事後分布はあくまでも**分布**であって、1つの推定「真」値ではないことである。つまり、ベイズ推論の結果であっても**確率的**であることに変わりはない。また、実際のパラメータ値に対する私たちの**信念**を表すという意味で、**主観的**なものでもある。したがって、ベイズ統計学では、推定値の信頼区間を計算するのではなく、**信用（確信）区間** (Credible Interval, CrI) を計算するのである。

ここで、先ほど説明した3つの分布が、具体的な例ではどのように見えるかを可視化してみよう。

```{r, message = F, out.width = '93%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/prior_col_sep.png')
```

\index{Markov Chain Monte Carlo}
\index{Gibbs Sampler}

ベイズアプローチのもう一つの利点は、パラメータが可視化されたようなベルカーブ分布に従う必要がないことである。他の種類の（より複雑な）分布もモデル化することができる。しかし、ベイズ推定の欠点は、収集したデータから（結合）分布を生成するのに、非常に計算コストがかかることである。事後分布を生成するために、**Gibbs サンプリング法**などの特殊な**マルコフ連鎖モンテカルロ**シミュレーション手法が開発された。マルコフ連鎖モンテカルロは、ベイジアンネットワークメタ分析モデルを実行するための **{gemtc}** パッケージでも使用されている [@van2012automating]。

<br></br>

### ベイズ的ネットワークメタ分析モデル {#bayesian-net-ma-model}

---


#### ペアワイズメタ分析

---

ここでは、**{gemtc}** がネットワークメタ分析に用いるベイズ型階層モデルを定式化する。まず、従来のペアワイズメタ分析のモデルを最初に定義することから始めましょう。

\index{Bayesian Hierarchical Model}

この定義は、「標準的な」ランダム効果モデルについて説明した Chapter \@ref(rem)  の定義と同等である。以下に述べるのは、メタ分析を概念化するための「ベイズ的な方法」に過ぎない。一方、このベイズ的なペアワイズメタ分析の定義は、これ以上拡張しなくても、ネットワークメタ分析に直接適用できるので、すでに非常に有益なものとなっている [@dias2013evidence]。

このモデルをベイズ型**階層**モデルと呼んでいる [@efthimiou2016getreal、より詳細な議論は Chapter \@ref(bayes-hierarchical-model) を参照]。ここで言う「階層的」というのは、何も不思議なことではない。実際、メタ分析・モデルは階層構造、つまり「多階層」を前提としていることは、既に Chapter \@ref(multilevel-ma) で説明した。

例えば、従来のメタ分析を実施するとしよう。$K$ 件の研究が含まれ、各研究の観測された効果量 $\hat\theta_k$ を計算する。そして、固定効果モデルを次のように定義する。

\begin{equation}
\hat\theta_k \sim \mathcal{N}(\theta,\sigma_k^2)
(\#eq:nw11)
\end{equation}

この式は、効果量が正規分布に従うと仮定して、効果量の**尤度**式中の $P(\boldsymbol{Y}|\boldsymbol{\theta})$ 部分を表現したものである。各効果量は同じ分布からの抽選であり、その平均が真の効果量 $\theta$、分散が $\sigma^2_k$ であると仮定する。固定効果モデルでは、真の効果量は全ての研究で同一であると仮定するので、異なる研究 $k$ とその観測された効果量 $\hat\theta_k$ に対して、$\theta$ は変わらない。

\index{Uninformative Prior}
\index{Prior Distribution}

ベイズモデルの面白いところは、本当の効果 $\theta$ が未知でも、その事前分布を定義できることである。この事前分布は、$\theta$ がどのように見えると考えるかを近似する。例えば、平均が0の正規分布に基づく事前分布を $\theta \sim \mathcal{N}(0, \sigma^2)$ (ここで $\sigma^2$ を指定)と仮定することが可能である。

**{gemtc}** パッケージでは、デフォルトで **uninformative priors** と呼ばれる、分散が非常に大きな事前分布を使用する。これは、事前の「信念」が事後結果に大きな影響を与えないようにするためで、主に実際に観測されたデータに「語らせる」ようにする。この式は、ランダム効果モデルに簡単に拡張することができる。

\begin{equation}
\hat\theta_k \sim \mathcal{N}(\theta_k,\sigma_k^2)
(\#eq:nw12)
\end{equation}

この式は、各研究が同じ真の効果量 $\theta$ の推定量であると仮定しないことを除けば、あまり変わらない。その代わりに、各観測効果量 $\hat\theta_k$ によって推定される "試験固有"の真の効果量 $\theta_k$ が存在すると仮定する。さらに、これらの研究固有の真の効果は、真の効果量の包括的な分布の一部である。この真の効果量分布は、その平均値 $\mu$ と分散 $\tau^2$（私たちの研究間異質性）によって定義される。

\begin{equation}
\theta_k \sim \mathcal{N}(\mu,\tau^2)
(\#eq:nw13)
\end{equation}

また、ベイズモデルでは、$\mu$ と $\tau^2$ の両方に（非情報的な）事前分布を与える。

<br></br>

#### ネットワークメタ分析への拡張

---

さて、ベイズメタ分析モデルが1対比較のためにどのように定式化されるかをカバーしたので、それをネットワークメタ分析に拡張することを始めましょう。前のランダム効果モデルの2つの公式は、このために再利用することが可能である。我々は、モデル・パラメータを少し違った形で概念化するだけである。ネットワークメタ分析では、比較対象が様々な治療法からなることがあるので、ある研究 $k$ で見つかった効果量を $\hat\theta_{k \text{,A,B}}$  で表す。これは、治療Aと治療Bを比較した研究 $k$ における効果量を意味する。この新しい表記法を適用すると、以下の式が得られる。

\begin{align}
\hat\theta_{k \text{,A,B}} &\sim \mathcal{N}(\theta_{k \text{,A,B}},\sigma_k^2) \notag \\
\theta_{k \text{,A,B}} &\sim \mathcal{N}(\theta_{\text{A,B}},\tau^2) (\#eq:nw14)
\end{align}

式で表される一般的な考え方は変わらないことがわかる。ここで、A $-$ B比較の（研究固有の）真の効果、$\theta_{k \text{,A,B}}$ は、平均 $\theta_{text{A,B}}$ を持つ真の効果の包括的分布の一部であると仮定する。この平均真の効果量 $\theta_{1\text{,A,B}}$ は、$\theta_{1\text{,B}}$ から $\theta_{1\text{,A}}$ を減算した結果であり、$\theta_{1\text{,A}}$ はある定義済みの参照治療 $1$ と比べた治療Aの効果である。同様に、$\theta_{1\text{,B}}$は、同じ参照治療と比較した治療Bの効果として定義されている。ベイズモデルでは、参照群と比較したこれらの効果も事前分布を与えられる。

前章の頻度論的ネットワークメタ分析ですでに述べたように、マルチアーム研究をネットワークモデルに含めることは、効果量が相関してしまうので問題がある。ベイズネットワークメタ分析では、この問題は、マルチアーム研究の効果が**多変量**（正規）分布に由来すると仮定することによって解決することが可能である。

マルチアーム試験 $k$ が、合計 $n=$ 5 の治療法を調べたとする。E を参照治療とすると、$n$ - 1 = 4 の治療効果があることになる。ベイズ階層モデルを用いて、これらの観測された治療効果が次の形式の多変量正規分布からのドローであると仮定する^[実際には、多群試験における試験間不均一性分散は、通常それぞれの比較間で**同質** (つまり、同一)であると仮定される。これにより、行列内のすべての共分散を $\tau^2/2$ として定義することがが可能である]。

  
\begin{align}
 \begin{bmatrix}
 \hat\theta_{k\text{,A,E}} \\
 \hat\theta_{k\text{,B,E}} \\
 \hat\theta_{k\text{,C,E}} \\
 \hat\theta_{k\text{,D,E}} 
 \end{bmatrix}
 &=
 \mathcal{N}\left(
 \begin{bmatrix}
 \theta_{\text{A,E}} \\
 \theta_{\text{B,E}} \\
 \theta_{\text{C,E}} \\
 \theta_{\text{D,E}}
 \end{bmatrix}
 ,
 \begin{bmatrix}
 \tau^2 & \tau^2/2 & \tau^2/2 & \tau^2/2 \\
 \tau^2/2 & \tau^2 & \tau^2/2 & \tau^2/2 \\
 \tau^2/2 & \tau^2/2 & \tau^2 & \tau^2/2 \\
 \tau^2/2 & \tau^2/2 & \tau^2/2 & \tau^2 
 \end{bmatrix}
 \right).
 (\#eq:nw15)
\end{align}


<br></br>

### _R_ におけるベイズ的ネットワークメタ分析

---

\index{gemtc Package}

それでは、最初のベイジアンネットワークメタ分析を行うために、**{gemtc}** パッケージを使用してみよう。いつものように、まずパッケージをインストールし、ライブラリからロードする必要がある。

```{r, message=F, warning=F}
library(gemtc)
```

\index{Gibbs Sampler}
\index{JAGS}
\index{rjags Package}

**{gemtc}** パッケージは、以前説明した Gibbs サンプリング手順で使用する **{rjags}** [@rjags] に依存している（Chapter \@ref(bayesian-inference) 参照）。ただし、このパッケージをインストールして読み込む前に、まず **JAGS** (Just Another Gibbs Sampler の略) という別のソフトをインストールする必要がある。このソフトは Windows と Mac の両方に対応しており、[インターネット](https://sourceforge.net/projects/mcmc-jags/files/)から無料でダウンロード可能。これが完了したら、**{rjags}** パッケージをインストールして読み込むことができる^[技術的には、**JAGS**はコンピュータプログラムであるだけでなく、**{gemtc}**がバックグラウンドで使用しているベイズモデリングのためのプログラミング言語でもある（マニュアルは  [こちら](https://people.stat.sc.edu/hansont/stat740/jags_user_manual.pdf) から見ることがが可能である）。JAGS自体は、1980年代後半から存在する**BUGS**（「Bayesian inference Using Gibbs Sampling」の略）言語に大きく依存している [@lunn2012bugs, chapter 2.2.1]]。

\vspace{2mm}

```{r, eval=F}
install.packages("rjags")
library(rjags)
```

<br></br>

#### データを準備

---

この例では、すでに頻出ネットワークメタ分析に使用した `TherapyFormats` データセットを再び使用する。しかし、**{gemtc}** で使用できるように、データの構造を少し調整する必要がある。

元の `TherapyFormats` データセットには `TE` と `seTE` という列があり、各行が1つの比較を表す標準化平均値と標準誤差が格納されている。このような相対効果データを **{gemtc}** で使用したい場合、各行が1つの**治療群**を表すようにデータフレームの形を変更する必要がある。さらに、効果量の列に`NA`を記入して、比較でどの治療が参照群として使われたかを指定する必要がある。このように整形したデータセットを "TherapyFormatsGeMTC" という名前で保存している^[また、「より広い」**{netmeta}** 形式のネットワークメタ分析データを、**{gemtc}**の相対効果量データに必要な「Long」形式に変換する方法を説明する _R_ vignette を用意する。この vignette は、 https://www.protectlab.org/vignettes/reshape-gemtc/ で見ることが可能である]。

\index{dmetar Package}

```{block, type='boxinfo'}
**"TherapyFormatsGeMTC" データセット**

\vspace{2mm}

`TherapyFormatsGeMTC` データセットは **{dmetar}** パッケージに含まれている。**{dmetar}** をインストールし、ライブラリからロードした後、 `data(TherapyFormatsGeMTC)` を実行すると、自動的にデータセットが _R_ 環境にセーブされる。これでデータセットが利用できるようになる。もし、**{dmetar}** がインストールされていない場合は、[インターネット](https://www.protectlab.org/meta-analysis-in-r/data/TherapyFormatsGeMTC.rda) から _.rda_ ファイルとしてダウンロードし、作業ディレクトリに保存した後、R Studio のウィンドウでクリックするとインポートすることが可能である。

```


`TherapyFormatsGeMTC` データセットは、2つの要素を持つリストで、そのうちの1つは `data` と呼ばれるものである。この要素は、モデルを適合させるために必要なデータフレームである。それでは、見ていこう。

```{r, warning=F, message=F, eval=F}
library(dmetar)
data(TherapyFormatsGeMTC)

head(TherapyFormatsGeMTC$data)
```

```{r, warning=F, message=F, echo=F}
library(dmetar)
load("data/TherapyFormatsGeMTC.rda")
head(TherapyFormatsGeMTC$data)
```


**{gemtc}** パッケージを使う際は、データフレームの列名を**{gemtc}** が指定する列名にする必要がある。連続的な結果（平均差や標準化平均差など）に基づく効果量を使用する場合、以下の列名が必要である。

* **`study`**. この列には、ネットワークに含まれる各研究の（ユニークな）ラベルが含まれ、**{netmeta}**で使用されている `studlab` 列と同じである。

* **`treatment`**. この列は治療法のラベルまたは短縮コードを含む。

* **`diff`**. この列には、比較のために計算された効果量（例えば、標準化された平均差）が含まれる。`diff` 列には、比較で使用された参照治療の行は`NA`（欠損）とする必要がある。そして、参照治療が比較された治療の行には、この比較のために計算された実際の効果量が格納される。また、参照カテゴリは、**比較単位**ではなく、**試験単位**で定義されていることに留意されたい。これは、多群間試験において、他のすべての治療が比較される参照治療は1つしかないことを意味する。例えば、3群間研究では、2つの効果量を含める必要がある。1つは参照グループと比較した第一治療、もう1つは参照グループと比較した第二治療の効果量である。

* **`std.err`**. この列は、効果量の標準誤差を含む。参照群では`NA`に設定され、参照群と比較された治療法の行でのみ定義される。

２値アウトカムのデータなど、他のデータ入力フォーマットも可能である。効果量データの種類によって、データセットがどのように構成される必要があるかは、**{gemtc}** のドキュメントで詳しく説明されている。コンソールで `?mtc.model` を実行し、"Details" セクションにスクロールすることでアクセスが可能である。

<br></br>

#### ネットワークグラフ

---

さて、データの準備ができたので、これを `mtc.network` 関数に渡す。これにより、`mtc.network` クラスのオブジェクトが生成され、後のモデル作成段階で使用することが可能である。あらかじめ計算された効果量データを使用するため、`mtc.network` の `data.re` 引数でデータセットを指定する必要がある。生の効果量データ（例：平均、標準偏差、サンプルサイズ）を使用する場合は、`data.ab` 引数を使用することになる。

オプションの `treatments` 引数を使用すると、ネットワークに含まれるすべての治療の実際の名前を **{gemtc}** に提供することが可能である。この際、データフレームの列名は `id` と `description` でなければならない。ここでは事前にデータフレームを作成し、`TherapyFormatsGeMTC`に `treat.codes` として保存してある。

```{r}
TherapyFormatsGeMTC$treat.codes
```

このデータフレームと `TherapyFormatsGeMTC` の効果量データを使って、 `mtc.network` オブジェクトを作成する。それを `network` という名前で保存する。

```{r}
network <- mtc.network(data.re  = TherapyFormatsGeMTC$data,
                       treatments = TherapyFormatsGeMTC$treat.codes)
```

作成されたオブジェクトを `summary` 関数に代入すると、すでにネットワークに関する興味深い情報を得ることが可能である。

```{r, eval=F}
summary(network)
```

```
## $Description
## [1] "MTC dataset: Network"
## 
## $`Studies per treatment`
## ind grp gsh tel wlc cau ush 
##  62  52  57  11  83  74  26  
## 
## $`Number of n-arm studies`
## 2-arm 3-arm 
##   181     1 
## 
## $`Studies per treatment comparison`
##     t1  t2 nr
## 1  ind tel  4
## 2  ind wlc 18
## 3  grp ind  7
## [...]
```

\index{Network Graph}

また、`plot`関数を使用してネットワークプロットを生成することもが可能である。**{netmeta}** パッケージで生成されたネットワークと同様に、エッジの太さはその比較に含めた研究数に対応している。

\vspace{2mm}

```{r, fig.width=8, fig.height=8, fig.align="center", out.width="65%", message=F, warning=F, eval=F}
plot(network, 
     use.description = TRUE) # Use full treatment names
```


```{r, fig.width=9, fig.height=8, fig.align="center", out.width="55%", message=F, warning=F, echo=F}
par(bg="#FFFEFA")
plot(network, 
     use.description = TRUE) # Use full treatment names
```

\vspace{2mm}

別の方法として、**Fruchterman-Reingold アルゴリズム**を用いて、ネットワークのより良い視覚化を作成できるかどうかを確認することもが可能である。このアルゴリズムには固有のランダム性があるため、結果を再現できるように seed を設定する必要がある。

ネットワークプロットは **{igraph}** パッケージ [@igraph] を使って作成される。このパッケージがインストールされ、ロードされたとき、プロットの外観を変えるために他の引数も使うことが可能である。異なるスタイルオプションの詳細な説明はオンラインの **{igraph}** [manual](https://igraph.org/r/doc/plot.common.html) にある。

\vspace{2mm}

```{r, fig.width=10, fig.height=8, fig.align="center", out.width="55%", message=F, warning=F, eval=F}
library(igraph)
set.seed(12345) # 再現性のため seed を設定

plot(network, 
     use.description = TRUE,            # Use full treatment names
     vertex.color = "white",            # node color
     vertex.label.color = "gray10",     # treatment label color
     vertex.shape = "sphere",           # shape of the node
     vertex.label.family = "Helvetica", # label font
     vertex.size = 20,                  # size of the node
     vertex.label.dist = 2,             # distance label-node center
     vertex.label.cex = 1.5,            # node label size
     edge.curved = 0.2,                 # edge curvature
     layout = layout.fruchterman.reingold)
```

```{r, fig.width=10, fig.height=8, fig.align="center", out.width="55%", message=F, warning=F, echo=F}
library(igraph)
set.seed(12345) # set seed for reproducibility
par(bg="#FFFEFA")
plot(network, 
     use.description = TRUE,            # Use full treatment names
     vertex.color = "white",            # node color
     vertex.label.color = "gray10",     # treatment label color
     vertex.shape = "sphere",           # shape of the node
     vertex.label.family = "Helvetica", # label font
     vertex.size = 20,                  # size of the node
     vertex.label.dist = 2,             # distance label-node center
     vertex.label.cex = 1.5,            # node label size
     edge.curved = 0.2,                 # edge curvature
     layout = layout.fruchterman.reingold)
```


<br></br>

#### モデルのコンパイル

---

`mtc.network` オブジェクトを使用して、モデルの指定とコンパイルを開始することが可能である。**{gemtc}** パッケージの素晴らしいところは、ベイズ推定プロセスのほとんどの部分を自動化できることである。例えば、モデル中のすべてのパラメータに対して適切な事前分布を選択することが可能である。

\index{Markov Chain Monte Carlo}

このように、`mtc.model` 関数を用いてモデルをコンパイルする際に指定しなければならない引数はごくわずかである。まず、前に作成した `mtc.network` オブジェクトを指定する。さらに、`linearModel` 引数を用いて、ランダム効果モデルか固定効果モデルのどちらを使用するかを決定しなければならない。頻度論的分析では、かなりの異質性と不整合が見られたため (Chapter \@ref(net-heat-plot) 参照)、`linearModel = "random"` を使用する。また、使用する**マルコフ連鎖**の数を指定する必要がある。ここでは、3から4の間の値が賢明で、`n.chain = 4` とする。

さらに、オプションで `likelihood` と `link` という2つの引数を指定することが可能である。この2つの引数は、使用している効果量データの種類によって異なり、明示的に指定しない限りは **{gemtc}** によって自動的に推測される。我々は連続的な結果データ（SMD など）に基づく効果量を扱っているので、「正規」 (normal) の尤度と 「同一」 (indetity) のリンクを仮定している。

２値アウトカム（対数オッズ比など）を使用していた場合、適切な尤度 (likelyhood) とリンク (link) はそれぞれ `"binom"` （二項）と `"logit"` である。これに関する詳細は `mtc.model` のドキュメントに記載されている。しかし、前のステップでデータが正しく準備されている場合には、通常 `mtc.model` は自動的に正しい設定を選択する。

```{r}
# コンパイル済みモデルを "model" と命名
model <- mtc.model(network,
                   likelihood = "normal",
                   link = "identity",
                   linearModel = "random",
                   n.chain = 4)
```


<br></br>

#### マルコフ連鎖モンテカルロ法サンプリング

---

\index{Markov Chain Monte Carlo}

さて、いよいよ分析の重要な部分であるマルコフ連鎖モンテカルロ法（MCMC）サンプリングに入る。MCMCシミュレーションは、パラメータの事後分布を推定し、ネットワークメタ分析の結果を生成することが可能である。この手順で達成したい重要な望みが2つある。

* マルコフ連鎖モンテカルロ法の最初の数回の実行が、シミュレーションの結果に大きな影響を与えないようにしたい。

* マルコフ連鎖モンテカルロ法は、モデルパラメータの正確な推定値を得るために十分な時間実行する必要がある（すなわち、**収束**する必要がある）。

これらの点を解決するために、マルコフ連鎖モンテカルロ法のアルゴリズムがモデル結果を推論するために反復する回数を**2つのフェーズ**に分割した：まず、**burn-in**反復回数（`n.adapt`）を定義し、その結果は破棄される。次のフェーズでは、モデルパラメータの推定に実際に使用するシミュレーションの反復回数(`n.iter`)を指定する。

通常、多くの反復計算を行うため、`thin`引数を指定することで、$i$番目の反復計算の値のみを抽出することもが可能である。これにより、必要なコンピュータのメモリを削減することが可能である。

シミュレーションは `mtc.run` 関数を用いて行うことが可能である。この例では、異なる設定で2回実行し、どちらがより効果的かを比較する。コンパイルした `model` オブジェクトを関数に与え、先ほど説明したパラメータを指定する必要がある。

まず、数回の繰り返しのシミュレーションをおこない、次に、大きな繰り返しのシミュレーションをおこないる。両方のオブジェクトをそれぞれ `mcmc1` と `mcmc2` という名前で保存する。ネットワークの大きさによっては、シミュレーションが終了するまでに時間がかかることがある。

\vspace{2mm}


```{r, eval=F}
mcmc1 <- mtc.run(model, n.adapt = 50, n.iter = 1000, thin = 10)
mcmc2 <- mtc.run(model, n.adapt = 5000, n.iter = 1e5, thin = 10)
```


<br></br>

#### モデルの収束を評価 {#bayesian-model-convergence}

---

シミュレーションの結果、アルゴリズムが収束したかどうか、また、どの設定が好ましいかを確認するために、`mcmc1` と `mcmc2` オブジェクトの出力をいくつか評価することが可能である。 `plot` 関数を使用することは、良いスタートである。これは、すべての反復における各治療比較について、一般的に**trace plot**と呼ばれる一種の 「時系列」を提供する。この例では、個人セラピー（`ind`）と待機者コントロール（`wlc`）の比較の推定値にのみ焦点を当てる。

```{r, eval=F}
plot(mcmc1)
plot(mcmc2)
```


```{r ch14-1353, echo=F, fig.width = 10, fig.height=4, fig.align="center", out.width="50%"}
load("data/mcmc1.rda")
load("data/mcmc2.rda")

library(coda)
library(purrr)

mcmc1[["samples"]] %>% 
  map(function(x) {
    x[,"d.ind.wlc"]
  }) %>% as.mcmc.list() -> mcmc1.tp

mcmc2[["samples"]] %>% 
  map(function(x) {
    x[,"d.ind.wlc"]
  }) %>% as.mcmc.list() -> mcmc2.tp



coda:::plot.mcmc.list(as.mcmc.list(mcmc1.tp),
                      density = F,
                      col = "gray50",
                      main = "Trace of d.ind.wlc (mcmc1)") # remove for color plots

coda:::plot.mcmc.list(as.mcmc.list(mcmc2.tp),
                      density = F,
                      col = "gray50",
                      main = "Trace of d.ind.wlc (mcmc2)") # remove for color plots
```


`mcmc1` の前半と後半の繰り返しを比較すると、時系列全体のトレンドに若干の不連続性があることがわかる。4種類の連鎖の推定値（4本の線）は、プロットの前半から後半に移るときに、そのコースがわずかに異なっている。一方、`mcmc2` のプロットでは、上下の変動はより急激であるが、長期的なトレンドは見られない。これは、`mcmc2` の設定がより適切であることを示す最初の兆候である^[信頼性のため、推定パラメータのマルコフ連鎖は、シミュレーションの過程で**静態性** (stationarity) に到達している必要がある。これはすべての線が共通の安定した平均値の周りにランダムに散らばることを意味する。このポイントに達すると、トレースプロットの鎖は典型的に "fat hairy caterpillar" [@lunn2012bugs, chapter 4.4.1] に類似する。]。

事後効果量推定値の密度プロットを見ることで、収束の評価を続けることが可能である。`mcmc1` の分布はまだ滑らかな正規分布から多少乖離しているが、`mcmc2` の結果は古典的なベルカーブに近づいていることがわかる。


\vspace{2mm}

```{r, echo=F, fig.width = 6, fig.height=5, out.width="50%"}
load("data/mcmc1.rda")
load("data/mcmc2.rda")

library(coda)
library(purrr)

mcmc1[["samples"]] %>% 
  map(function(x) {
    x[,"d.ind.wlc"]
  }) %>% as.mcmc.list() -> mcmc1.tp

mcmc2[["samples"]] %>% 
  map(function(x) {
    x[,"d.ind.wlc"]
  }) %>% as.mcmc.list() -> mcmc2.tp


coda:::plot.mcmc.list(as.mcmc.list(mcmc1.tp),
                      density = T,
                      trace = F,
                      col = 1,
                      main = "Density of d.ind.wlc (mcmc1)") # remove for color plots

coda:::plot.mcmc.list(as.mcmc.list(mcmc2.tp),
                      density = T,
                      trace = F,
                      col = 1,
                      main = "Density of d.ind.wlc (mcmc2)") # remove for color plots
```

\index{Potential Scale Reduction Factor}

収束を評価するのに非常に有用なもう一つの方法は、**Gelman-Rubin プロット**である。このプロットは、いわゆる**潜在的スケール削減係数** (Potential Scale Reduction Factor, PSRF) （訳注 PSRF の訳語はまだ定まっていない。） を示し、各チェーン内のばらつきとチェーン間のばらつきを比較し、両者が時間とともにどのように発展していくかを示している。収束した場合、PRSF は反復回数の増加とともに徐々にゼロまで縮小し、最終的には少なくとも 1.05 以下になるはずである。

このプロットを作成するには、`mtc.run` オブジェクトを `gelman.plot` 関数に代入するだけでよい。両方のシミュレーションの結果を示す（ここでも `ind` と `wlc` の比較のみ）。

\vspace{2mm}

```{r, eval=F}
gelman.plot(mcmc1)
gelman.plot(mcmc2)
```


```{r, echo=F, fig.width = 5, fig.height=5, out.width="50%"}
load("data/mcmc1.rda")
load("data/mcmc2.rda")

library(coda)
library(purrr)

mcmc1[["samples"]] %>% 
  map(function(x) {
    x[,"d.ind.wlc"]
  }) %>% as.mcmc.list() -> mcmc1.tp

mcmc2[["samples"]] %>% 
  map(function(x) {
    x[,"d.ind.wlc"]
  }) %>% as.mcmc.list() -> mcmc2.tp

gelman.plot(mcmc1.tp, main = "Gelman-Rubin Plot of d.ind.wlc (mcmc1)")
gelman.plot(mcmc2.tp, main = "Gelman-Rubin Plot of d.ind.wlc (mcmc2)")

```

また、このコードを使って、モデルの**全体的な** PSRF に直接アクセスすることが可能である。


```{r, eval=F}
gelman.diag(mcmc1)$mpsrf
```

```
## [1] 1.034131
```

```{r, eval=F}
gelman.diag(mcmc2)$mpsrf
```

```
## [1] 1.000351
```


両方のシミュレーションで PRSF は閾値を下回っているが、`mcmc2` の値はずっと低く、1に非常に近いことがわかる。これは、2番目のモデルを使用すべきことを示している。


<br></br>

#### 非整合性の評価: ノード分割法

---

**{netmeta}** パッケージと同様に、**{gemtc}** パッケージもネットワークモデルの整合性を評価する方法を提供している。すなわち、ノード分割 (_nodesplit_) 法である (Dias et al., 2010)。この手順の考え方は、以前説明した net splitting 法のものと似ている (Chapter \@ref(net-splitting))。ノード分割分析を行うには、`mtc.nodesplit` 関数を使用し、`mcmc2` と同じ設定を使用する。解析結果は `nodesplit` という名前で保存しよう。

_nodesplit_ モデルの計算には、ネットワークの複雑さによっては数時間かかることがある。


\index{Node Splitting}
\index{Consistency}

```{r, echo=F}
load("data/nodesplit.rda")
```


```{r, eval=F}
nodesplit <- mtc.nodesplit(network, 
                           linearModel = "random", 
                           likelihood = "normal",
                           link = "identity",
                           n.adapt = 5000, 
                           n.iter = 1e5, 
                           thin = 10)
```

`summary` 関数を使用すると、結果を表示することができる。

```{r, eval=F}
summary(nodesplit)
```

```
## Node-splitting analysis of inconsistency
## ========================================
## 
##    comparison  p.value CrI                  
## 1  d.ind.tel   0.62785                      
## 2  -> direct           0.13 (-0.39, 0.64)   
## 3  -> indirect         -0.037 (-0.46, 0.38) 
## 4  -> network          0.034 (-0.30, 0.36)  
## 5  d.ind.wlc   0.87530                      
## 6  -> direct           1.0 (0.74, 1.3)      
## 7  -> indirect         0.97 (0.71, 1.2)     
## 8  -> network          0.98 (0.80, 1.2)     
## 9  d.ind.grp   0.61380                      
## 10 -> direct           0.14 (-0.29, 0.57)   
## 11 -> indirect         0.26 (0.044, 0.48)   
## 12 -> network          0.24 (0.041, 0.43)   
## [...]
```


この関数の出力は、直接証拠のみ、間接証拠のみ、利用可能なすべての証拠を用いた場合の、異なる比較の効果についての結果を示している。直接証拠と間接証拠を用いた異なる推定値は、矛盾の存在を示唆する。ベイズの `p.value` 列を見ることによって、これをコントロールすることが可能である。$p<$ 0.05の1つ以上の比較は、このネットワークに矛盾があることを示すので、問題がある。出力から、この（ランダム効果モデルの）例では矛盾がないことがわかる。

ノード分割法によって複数の推定値に矛盾を示す場合、デザイン間の潜在的な差異について、含まれる**すべての**エビデンスを再度確認することが重要である。例えば、AとBを比較した研究では、Aを評価した他の研究とは系統的に異なる母集団が含まれている可能性がある。

もう一つのアプローチは、研究の賢明な部分集合のみがネットワークに含まれる場合に、矛盾が持続するかどうかを確認することである。最後に、後述するネットワークメタ回帰を実行することによって、矛盾の理由を評価することも可能である。

\index{Forest Plot}\index{フォレストプロット}

ノードスプリットモデルに対して、`plot` 関数を用いてフォレストプロットを生成することも可能である。しかし、先に nodesplit オブジェクトを `summary` に代入後、フォレストプロットが生成される。



```{r, eval=F}
plot(summary(nodesplit)) 
```

```{r, message = F, out.width = '90%', echo = F, fig.align='center'}
library(OpenImageR)
knitr::include_graphics('images/nodesplit_forest_sep.png')
```

<br></br>

#### ネットワークメタ解析結果の生成

---

さて、ネットワークメタ分析モデルを適合させ、それが信頼できるものであると確信したところで、いよいよ結果を出すときが来た。

前に述べたように、ネットワークメタ分析で答えたい主な疑問は、どの治療が一番よく効くかということである。この質問に答えるために、まず `rank.probability` 関数を実行することが可能である。この関数は、ある治療法が最も良い選択である確率、2番目に良い選択である確率、3番目に良い選択である確率、などを計算する。この関数は入力として `mcmc2` オブジェクトを必要とし、さらに `preferredDirection` という引数を指定する。もし、より小さい（つまり、負の）効果量がより良い結果を示すのであれば、この引数を `-1` に設定する。それ以外の場合は `1` を使用する。

結果は `rank` という名前で保存され、いわゆる **rankogram** を用いて可視化される。

```{r, fig.height=4, fig.width=7, out.width="65%", fig.align="center", eval=F}
rank <- rank.probability(mcmc2, preferredDirection = -1)
plot(rank, beside=TRUE)
```

```{r, fig.height=4, fig.width=7, out.width="65%", fig.align="center", echo=F}
rank <- rank.probability(mcmc2, preferredDirection = -1)
par(bg="#FFFEFA")
plot(rank, beside=TRUE)
```

このプロットでは、個人セラピー（ind）はおそらく私たちのネットワークで最良の治療オプションであることがわかる。なぜなら、ind の最初の棒（1位を意味する）が最も大きいからである。この発見は、同じパターンを発見した頻度論的分析の結果と一致する。

さらに、`forest` 関数を用いて、結果のフォレストプロットを作成することもできる。これを行うには、まず results オブジェクトを `relative.effect` 関数に入れ、参照治療である `t1` を指定する必要がある。ここでも参照群として care as usual (`"cau"`) を使用する。そして、結果に対して `forest` 関数を呼び出し、プロットを生成する。

```{r, fig.width=7, fig.height=3, fig.align="center", out.width="80%", eval=F}
forest(relative.effect(mcmc2, t1 = "cau"), 
       use.description = TRUE, # Use long treatment names
       xlim = c(-1.5, 0.5))
```

```{r, fig.width=7, fig.height=3, fig.align="center", out.width="80%", echo=F}
par(bg="#FFFEFA")
forest(relative.effect(mcmc2, t1 = "cau"), 
       use.description = TRUE, # Use long treatment names
       xlim = c(-1.5, 0.5))
```

\index{SUCRA Score}

頻度論的ネットワークメタ分析の章では、ネットワーク内のどの治療が最も効果的であるかを評価するメトリックとして P-score をすでに取り上げた。P-スコアに相当するのは、**Surface Under the Cumulative Ranking** (SUCRA)スコアで、これは次のように計算が可能である [@salanti2011graphical]。

\begin{equation}
\text{SUCRA}_j = \frac{\sum_{b=1}^{a-1}\text{cum}_{jb}}{a-1}
(\#eq:nw16)
\end{equation}

ここで、$j$ は何らかの治療法、$a$ は全ての競合する治療法、$b$ は $b = 1, 2, \dots, a-1$ の最良治療法、$\text{cum}$ はある治療法が $b$ 個の最良治療法の中にある**累積確率** を表す。 _R_ で SUCRA スコアを計算するには、`sucra` 関数を使用する。

\index{dmetar Package}

```{block, type='boxdmetar'}
**"sucra" 関数**

\vspace{4mm}

`sucra` 関数は **{dmetar}** パッケージに含まれている。**{dmetar}** がインストールされ、コンピュータに読み込まれると、この関数を使用できるようになる。もし、**{dmetar}** をインストールしていない場合は、以下の手順でインストールできる。

\vspace{2mm}

1. 関数の [online](https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/sucra.R) のソースコードにアクセスする。
2. ソースコード全体をコンソール(R Studioの左下ペイン)にコピー＆ペーストし、「Enter」キーを押して、 _R_ に関数を「学習」させる。
3. **{ggplot2}** パッケージがインストールされ、ロードされていることを確認する。


```


`sucra` 関数は入力として `rank.probability` オブジェクトだけを必要とするが、ここでは値が小さいほど良い結果を示すかことを指定する必要がある。これは `lower.is.better` という引数を用いて行うことが可能である。どのような結果が得られるか見てみよう。


```{r, message=F, warning=F, fig.height=3, fig.width=5, fig.align="center", out.width="40%", eval=F}
library(dmetar)
rank.probability <- rank.probability(mcmc2)
sucra <- dmetar::sucra(rank.probability, lower.is.better = TRUE)

sucra
```

```
##         SUCRA
## ind 0.9225292
## tel 0.8516583
## gsh 0.6451292
## [...]
```

```{r, message=F, warning=F, fig.height=3, fig.width=5, fig.align="center", out.width="40%", echo=F}
library(dmetar)
rank.probability <- rank.probability(mcmc2)
sucra <- dmetar::sucra(rank.probability, lower.is.better = TRUE)

```

```{r, message=F, warning=F, fig.height=4, fig.width=5, fig.align="center", out.width="50%"}
plot(sucra)
```

各治療の SUCRA 値を見ると、やはり個別治療 (ind) が最も良い選択肢と思われ、次いで電話による治療 (tel)、ガイド付きセルフヘルプ (gsh) が続く。

通常は、モデルに基づく各治療比較の効果量推定値を報告したい。治療効果表は、 `relative.effect.table` 関数を用いてエクスポートする。この関数の結果は `result` というオブジェクトに保存され、.csv ファイルとしてエクスポートすることも可能である。

`relative.effect.table` 関数は、推定効果と各比較の信頼区間を含む治療比較行列を自動的に作成する。

```{r, eval=F}
results <- relative.effect.table(mcmc2)
save(results, file = "results.csv")
```


<br></br>

### ネットワークメタ回帰

---

\index{Meta-Regression}\index{メタ回帰}\index{メタ回帰}
\index{gemtc Package}

**{gemtc}** パッケージの大きな特徴は、**ネットワークメタ回帰**を行うことができる点である。従来のメタ回帰と同様に、この機能を使って、特定の研究特性がネットワークで発見された効果量の大きさに影響を与えるかどうかを判断することが可能である。また、矛盾を説明する可能性のある変数をチェックするのに便利なツールである。


\index{Risk of Bias}

研究のバイアスのリスクが、ネットワークメタ分析における効果に影響を与えるかどうかを評価したいとする。たとえば、バイアス・リスクの高い研究は、一般に、対照群または代替治療と比較して、より高い効果を報告することが考えられる。モデルに予測因子として偏りのリスクを含めることで、そのような関連をコントロールし、結果への影響を評価することが可能である。

**{gemtc}** でネットワークメタ回帰を実行するには、共変量なしのベイズネットワークメタ分析モデルを適合させたときと同様のステップを踏む必要がある。まず、`mtc.network` を使用してネットワークを設定する必要がある。しかし、今回は `studies` という追加の引数を指定する。この引数には、各研究の予測変数の情報を格納したデータフレームを指定する。`TherapyFormatsGeMTC` データセットには、`study.info` という要素があり、各研究のバイアスリスクが格納されている。

それでは、データを簡単に見てみよう。

```{r, eval=F}
TherapyFormatsGeMTC$study.info
```

```
##                        study rob
## 1             Campbell, 2000   1
## 2             Reynolds, 1989   1
## 3            Carpenter, 1994   0
## 4             Shrednik, 2000   1
## [...]
```

\index{Dummy Variable}

このデータセットには2つの列が含まれている。`study` はネットワークに含まれる研究の名前、`rob` はそのバイアスリスクである。study のラベルは、実際の効果量データセットで使用されているものと完全に同一である必要があることに注意する必要がある。`rob` 変数はダミーコードの予測変数で、`0` は低バイアスリスク、`1` は高バイアスリスクを示す。`study.info` データフレームを使用して、`mtc.network` でメタ回帰ネットワークを作成することが可能である。


```{r, eval=F}
network.mr <- mtc.network(data.re = TherapyFormatsGeMTC$data,
                          studies = TherapyFormatsGeMTC$study.info,
                          treatments = TherapyFormatsGeMTC$treat.codes)
```

ここで、ネットワークメタ分析モデルに含めたい**回帰因子**を定義する必要がある。これは、3つの要素を持つリストオブジェクトを生成することで行うことが可能である。

* **`coefficient`**: この要素は、ネットワークメタ分析に含まれるすべての治療にわたる（高）バイアスリスクの効果について、1つの共有係数を推定したいので、`"shared"` に設定する。

* **`variable`**: 予測変数として使用したい変数の名前を指定する（ここでは `"rob"`）。

* **`control`**: 参照グループとして使用する治療法も指定しなければならない。この例では、`"cau"` (care as usual) を使用する。


```{r}
regressor <- list(coefficient = "shared",
                  variable = "rob",
                  control = "cau")
```


次に、モデルをコンパイルする。先ほど生成したネットワークを `mtc.model` 関数に与え、モデルのタイプを `"regression"` に設定し、先ほど生成した `regressor` オブジェクトを関数の引数に与える。出力結果は `model.mr` という名前で保存される。


```{r, eval=F}
model.mr <- mtc.model(network.mr,
                      likelihood = "normal",
                      link = "identity",
                      type = "regression",
                      regressor = regressor)
```

このステップの後、`mtc.run`関数を用いてモデルを実行することが可能である。`mcmc2` モデルのフィッティングに使用したのと同じ仕様を使用する。結果は `mcmc3` として保存される。

```{r, eval=F}
mcmc3 <- mtc.run(model.mr,
                 n.adapt = 5000,
                 n.iter = 1e5,
                 thin = 10)
```

```{r, echo=F}
load("data/mcmc3.rda")
```


では、`summary` 関数を使って結果を解析してみよう。

```{r, eval=F}
summary(mcmc3)
```

```
## Results on the Mean Difference scale
## [...]
## 
## 1. Empirical mean and standard deviation for each variable,
##    plus standard error of the mean:
## 
##              Mean      SD  Naive SE Time-series SE
## d.ind.cau  0.6992 0.07970 0.0003985      0.0004201
## d.ind.grp  0.1933 0.10009 0.0005005      0.0005321
## [...]
## B         -0.3297 0.13047 0.0006523      0.0010379
## 
## 2. Quantiles for each variable:
## 
##                2.5%      25%      50%     75%    97.5%
## d.ind.cau  0.542044  0.64602  0.69967  0.7529  0.85571
## d.ind.grp -0.002622  0.12599  0.19353  0.2608  0.38962
## [...]
## B         -0.586266 -0.41790 -0.32957 -0.2417 -0.07455
## 
## [...]
## -- Regression settings:
## 
## Regression on "rob", shared coefficients, "cau" as control
## Input standardized: x' = (rob - 0.4340659) / 1
## Estimates at the centering value: rob = 0.4340659
```

予測変数の結果は、`B`の隣に報告されている。予測変数はダミー・コード化されているので、 `B` の値は、バイアスの**高い**リスクを持つ研究の効果を表す。推定値は $b=$ -0.33 で、2番目の表（`Quantiles for each variable`）を見ると、$b$ の95% 信頼区間が -0.59 から -0.08 までであることがわかる。信頼区間には0が含まれないので、バイアスのリスクは確かに結果に影響すると結論づけられるであろう。バイアスのリスクが高いとき (`rob` = 1)、より高い全体効果を予測が可能である（この例では、負の効果量は「より良い」結果を示している）。

2つのフォレストプロットを生成することにより、予測変数の効果をさらに調査することができる。1つは、バイアスリスクが高いときの推定治療効果で、もう1つは、それが低いときのものである。これは `relative.effect` 関数を用いて行うことができ、ここで `covariate` 値を指定する。`covariate = 0` はバイアスリスクの低い研究を表し、`covariate = 1` はバイアスリスクの高い研究を表す。

\vspace{2mm}

```{r, fig.show='hold', fig.width=7, fig.height=3, fig.align="center", out.width="80%", eval=F}
forest(relative.effect(mcmc3, t1 = "cau", covariate = 1),
       use.description = TRUE, xlim = c(-1.5, 1))
title("High Risk of Bias")

forest(relative.effect(mcmc3, t1 = "cau", covariate = 0),
       use.description = TRUE, xlim = c(-1.5, 1))
title("Low Risk of Bias")
```

```{r, fig.show='hold', fig.width=7, fig.height=3, fig.align="center", out.width="80%", echo=F}
par(bg="#FFFEFA")
forest(relative.effect(mcmc3, t1 = "cau", covariate = 1),
       use.description = TRUE, xlim = c(-1.5, 1))
title("High Risk of Bias")
```

```{r, fig.show='hold', fig.width=7, fig.height=3, fig.align="center", out.width="80%", echo=F}
par(bg="#FFFEFA")
forest(relative.effect(mcmc3, t1 = "cau", covariate = 0),
       use.description = TRUE, xlim = c(-1.5, 1))
title("Low Risk of Bias")
```

フォレストプロットを比較すると、あるパターンが見えてくる。すなわち、バイアスリスクの高い研究に基づく治療効果は、一般に高い（よりマイナスである）。これは、予測変数の推定値と一致している。

\index{Akaike's Information Criterion}

最後に、先ほど生成したネットワークメタ回帰モデルが、先ほどの「通常の」ネットワークメタ分析モデルよりもデータにフィットしているかどうかを調べることもが可能である。これを行うには、**逸脱度情報量規準** (Deviance Information Criteria, DIC) を比較する。これは、頻度論統計学における AIC および BIC 値に相当する。以下のコードを用いて、`mcmc3` と `mcmc2` の両方の DIC にアクセスすることが可能である。

```{r}
summary(mcmc3)$DIC
summary(mcmc2)$DIC
```

メタ回帰モデルの DIC 値（261.19）は、バイアスリスクをコントロールしなかった以前のモデル（DIC = 323.6）より低いことが出力からわかる。DIC 値が低いほど、適合度が高いことを示している。この知見に基づき、私たちのネットワークメタ回帰モデルは、共変量なしのモデルよりもデータによく適合していると結論づけることが可能である。

\index{WinBUGS}

```{block, type='boxinfo'}
**更なる学習**

\vspace{2mm}

以上、 _R_ を使ったネットワークメタ分析の簡単な紹介をした。ネットワークメタ分析の背後にある一般的な考え方、それに関連する仮定といくつかの注意点、ネットワークメタ分析を行うことができる2つの異なる統計的アプローチ、およびそれらが _R_ でどのように実装されているかを説明した。 

\vspace{2mm}

ここで取り上げたことは、あくまで大まかな概要として捉えていただきたい。主な落とし穴をいくつか取り上げたが、実際にネットワークメタ分析を始めると、やはり行き詰まる可能性がある。

\vspace{2mm}

ネットワークメタ分析について、またそれをどのように実際に適用できるかを知るための優れたリソースが、Dias et al. によって書かれた _Network Meta-Analysis for Decision-Making_ である [-@dias2018network]。この本では、いくつかの実践例も紹介されており、オープンソースのソフトウェア _WinBUGS_ を使用してネットワークメタ分析モデルを実行する方法が紹介されている。ネットワークメタ分析の「最先端」の短い（そしてかなり技術的な）概要は、Efthimiou et al.  によるオープンアクセス論文[-@efthimiou2016getreal]で見ることが可能である。

```

$$\tag*{$\blacksquare$}$$

<br></br>

## 演習問題

```{block, type='boxquestion'}
**知識を試そう！**

\vspace{4mm}

1. ネットワークメタ分析はどのような場合に有用か？標準的なメタ分析と比較して、どのような利点があるか？

\vspace{-2mm}

2. 治療ネットワークにおける直接エビデンスと間接エビデンスの違いは何か？間接エビデンスの生成に直接エビデンスをどのように利用できるのか？

\vspace{-2mm}

3. ネットワークメタ分析における推移性 (transitivity) の仮定の主な考え方は何か？

\vspace{-2mm}

4. 推移性 (transivity) と一貫性 (consistency) の関係は？

\vspace{-2mm}

5. ネットワークメタ分析に使用できる2つのモデリングアプローチを挙げなさい。どちらか一方が優れているか？

\vspace{-2mm}

6. 1つの試験から複数の比較を含める場合（マルチアーム試験など）、どのような問題が発生するか？

\vspace{-2mm}

7. 異なる治療法の P-スコアまたは SUCRA スコアを解釈する際、どのような点に注意しなければならないか？

\vspace{4mm}


**問題の解答は、本書の巻末 [Appendix A](#qanda12) にある。**

```

<br></br>

## 要約

* ネットワークメタ分析は、様々な治療や介入の**相対的効果**を共同で推定するのに有用なツールである。

* 治療効果を推定するために、ネットワークメタ分析は、直接（すなわち観察）証拠と間接証拠の両方を**結合**する。ただし、これには「推移性（交差性）」という前提がある。推移性は、2つの比較の直接証拠を組み合わせて、3つ目の比較についての有効な間接証拠を導き出すことができるときに満たされる。

* 推移性の**統計的な現れ**は一貫 (consistency) であり、その反対は矛盾 (inconsistency) である。矛盾は、直接証拠に基づく比較の真の効果が、間接証拠に基づくものと一致しないときに生じるものである。

* ノードスプリッティングやネットヒートプロットなどの手法により、ネットワーク内の矛盾を**特定する**ことができる。矛盾が見つかると、結果全体の妥当性が脅かされることになる。このような場合、研究／デザイン間の系統的な差異を引き起こした可能性のある特性をネットワーク全体でチェックする必要がある。 

* ネットワークメタ分析は、**頻度論的**または**ベイズ的**アプローチのいずれかを使用して可能である。実際には、これらの方法にはそれぞれ長所があるが、通常、全体的な結果は非常に似ている。

* ベイズ型階層モデルに基づくネットワークメタ分析では、効果量の差を予測する**研究共変量**を加えることもが可能である。この結果、ネットワークメタ回帰モデルになる。

* SUCRA や P-score などの指標は、私たちのネットワークにおいて、どのタイプの治療が最も効果的であるかを調べるために使用することが可能である。しかし、意思決定プロセスに不確実性を組み込むことも重要である。異なる治療法の信頼区間は重なり合うこともよくあるので、1つの形式が他のすべての形式より本当に優れているかどうかは、あまり明確ではない。

