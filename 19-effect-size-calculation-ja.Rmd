# 効果量の計算と換算  {#es-calc}

---

<img src="_figs/effect_size_calculation.jpg" />

<br></br>

\index{meta Package}

メタ分析が頻繁に直面する問題は、適切な「生の」効果量データが、含まれるすべての研究から抽出できるとは限らないことである。`metacont` (Chapter \@ref(pooling-smd)) や `metabin` (Chapter \@ref(pooling-or-rr)) などの  **{meta}** パッケージのほとんどの関数は、生の効果量データが完全に利用可能な場合にのみ使用することができる。 

実際には、これは困難につながることも多い。出版された論文の中には、特に古いものでは、必要な（生の）効果量データを抽出できるような方法で結果を報告していないものがある。$t$-検定, one-way ANOVA, $\chi^2$-検定 の結果は報告されていても、メタ分析に必要なグループごとの平均や標準偏差、研究条件におけるイベント数が報告されていないことはよくあることである。 

\index{esc Package}

良いニュースは、報告された情報を望ましい効果量フォーマットに**変換**できる場合があるということである。これにより、`metagen` を用いた**事前計算**データ（Chapter \@ref(pre-calculated-es)）によるメタ分析で、影響を受けた研究を含めることができるようになる。例えば、2標本の $t$-検定 の結果を標準化平均差 (SMD) とその標準誤差に変換し、`metagen`  を用いて事前に計算された SMD のメタ分析を行うことができる。 **{esc}**  パッケージ [@esc] には、このような変換を _R_ 内で直接行うことができる便利な関数がいくつか用意されている。

<br></br>

## 平均値および標準誤差

---

\index{Mean, Arithmetic}
\index{Standardized Mean Difference}\index{標準化平均差}
\index{Hedges' \textit{g}}

平均と**標準誤差**から SMD や Hedges' $g$、平均の標準偏差はサンプルサイズの平方根を「割り算」して標準誤差として定義されることを利用することができる [@thalheimer2002calculate]。

\begin{equation}
\text{SD} =\text{SE}\sqrt{n}
(\#eq:esc1)
\end{equation}

SMD や Hedges' $g$ は `esc_mean_se`関数を使って計算することができる。以下はその例である。

```{r}
library(esc)

esc_mean_se(grp1m = 8.5,   # group 1 の平均
            grp1se = 1.5,  # group 1 の標準誤差
            grp1n = 50,    # group 1 のサンプル
            grp2m = 11,    # group 2 の平均
            grp2se = 1.8,  # group 2 の標準誤差
            grp2n = 60,    # group 2 のサンプル
            es.type = "d") # SMD に変換; Hedges' g を使う場合は "g"
```

<br></br>

## 回帰係数

---

標準化または非標準化回帰係数から SMD、Hedges' $g$  または相関 $r$  を計算することができる [@lipsey2001practical]。標準化されていない係数に対しては、 **{esc}**  の  `esc_B`  関数を使用することができる。以下はその例である。

\index{Correlation}\index{相関}\index{相関}

```{r}
library(esc)

esc_B(b = 3.3,       # 標準化されていない回帰係数
      sdy = 5,       # 予測変数 y の標準偏差
      grp1n = 100,   # group 1 のサンプルサイズ
      grp2n = 150,   # group 2 のサンプルサイズ
      es.type = "d") # SMD に変換; Hedges' g を使う場合は "g"
```

\vspace{2mm}

```{r, eval=F}
esc_B(b = 2.9,       # 標準化されていない回帰係数
      sdy = 4,       # 予測変数 y の標準偏差
      grp1n = 50,    # group 1 のサンプルサイズ
      grp2n = 50,    # group 2 のサンプルサイズ
      es.type = "r") # 相関係数に変換
```

```
## Effect Size Calculation for Meta Analysis
## 
##      Conversion: un標準化されていない回帰係数 
##                  to effect size correlation
##     Effect Size:   0.3611
##  Standard Error:   0.1031
##        Variance:   0.0106
##        Lower CI:   0.1743
##        Upper CI:   0.5229
##          Weight:  94.0238
##      Fisher's z:   0.3782
##       Lower CIz:   0.1761
##       Upper CIz:   0.5803
```

\vspace{2mm}

標準化された回帰係数は `esc_beta` を用いて変換することができる。

```{r}
esc_beta(beta = 0.32,   # 標準化されていない回帰係数
         sdy = 5,       # 予測変数 y の標準偏差
         grp1n = 100,   # group 1 のサンプルサイズ
         grp2n = 150,   # group 2 のサンプルサイズ
         es.type = "d") # SMD に変換; Hedges' g を使う場合は "g"
```

```{r, eval= F}
esc_beta(beta = 0.37,   # 標準化されていない回帰係数
         sdy = 4,       # standard deviation of predicted variable y
         grp1n = 50,    # group 1 のサンプルサイズ
         grp2n = 50,    # group 2 のサンプルサイズ
         es.type = "r") # 相関係数に変換
```

```
## Effect Size Calculation for Meta Analysis
## 
##      Conversion: 標準化されていない回帰係数 
##                  to effect size correlation
##     Effect Size:   0.3668
##  Standard Error:   0.1033
##        Variance:   0.0107
##        Lower CI:   0.1803
##        Upper CI:   0.5278
##          Weight:  93.7884
##      Fisher's z:   0.3847
##       Lower CIz:   0.1823
##       Upper CIz:   0.5871
```

<br></br>

## 相関関係  {#convert-corr}

---

\index{Correlation}\index{相関}\index{相関}
\index{Correlation, Point-Biserial}

**同じ**大きさの群（$n_1=n_2$）の場合、以下の式で**点-双列**相関から SMD を導き出すことができる [@lipsey2001practical, chapter 3]。

\begin{equation}
r_{pb} = \frac{\text{SMD}}{\sqrt{\text{SMD}^2+4}} ~~~~~~~~
\text{SMD}=\frac{2r_{pb}}{\sqrt{1-r^2_{pb}}} (\#eq:esc2)
\end{equation}

**不均等**な大きさの群には、別の数式を使用する必要がある [@aaron1998equating]。

\begin{align}
r_{pb} &= \frac{\text{SMD}}{\sqrt{\text{SMD}^2+\dfrac{(N^2-2N)}{n_1n_2}}} \notag \\
\text{SMD} &= \dfrac{r_{pb}}{\sqrt{(1-r^2)\left(\frac{n_1}{N}\times\left(1-\frac{n_1}{N}\right)\right)}} (\#eq:esc3)
\end{align}

 $r_{pb}$  を SMD や Hedges' $g$ に変換するには、  `esc_rpb` 関数を使用する。

```{r}
library(esc)

esc_rpb(r = 0.25,      # 点-双列相関
        grp1n = 99,    # group 1 のサンプルサイズ
        grp2n = 120,   # group 2 のサンプルサイズ
        es.type = "d") # SMD に変換; Hedges' g を使う場合は "g"
```

<br></br>

## 一元配置分散分析

---

\index{Analysis of Variance}\index{分散分析}

また、**2群**の一元配置の ANOVA の $F$-値から SMD を導き出すこともできる。そのような ANOVA は、**自由度**を見ることで識別できる。2つのグループの一元配置ANOVAでは、自由度は常に1から始まるはずである（例： $F_{\text{1,147}}$ =5.31）。 

変換に使う式は次のようなものである [@rosnow1996computing; @rosnow2000contrasts; @thalheimer2002calculate を参照]。

\begin{equation}
\text{SMD} = \sqrt{  F\left(\frac{n_1+n_2}{n_1 n_2}\right)\left(\frac{n_1+n_2}{n_1+n_2-2}\right)}
(\#eq:esc4)
\end{equation}

 $F$-値 から SMD や Hedges' $g$  を計算するには、  `esc_f` 関数を使用する。以下はその例である。

```{r}
esc_f(f = 5.04,      # one-way anova の F-値
      grp1n = 519,   # group 1 のサンプルサイズ 
      grp2n = 528,   # group 2 のサンプルサイズ
      es.type = "g") # Hedges' g　に変換; SMD の場合は "d"
```

<br></br>

## 2標本の $t$ 検定

---

\index{Standardized Mean Difference}\index{標準化平均差}

標準化平均差として表現される効果量は、以下の式 [@rosnow2000contrasts; @thalheimer2002calculate] を用いて、**独立**2サンプル $t$ -検定値からも導き出すことができる。

\begin{equation}
\text{SMD} = \frac {t(n_1+n_2)}{\sqrt{(n_1+n_2-2)(n_1n_2)}}
(\#eq:esc5)
\end{equation}

 _R_  では、`esc_t` 関数を使って $t$-値から SMD や Hedges' `g` を計算することができる。以下はその例である。

```{r}
esc_t(t = 3.3,     # t-値
      grp1n = 100, # group 1 のサンプルサイズ
      grp2n = 150, # group 2 のサンプルサイズ
      es.type="d") # SMD に変換; Hedges' g を使う場合は "g"
```

<br></br>

## $p$ 値

---

\index{P-Value}\index{P-値}

研究では、効果の大きさ（例えば、Cohen's $d$ 値）、その効果の $p$ -値のみを報告し、それ以上のことは報告しないことがある。しかし、メタ分析で結果をプールするためには、効果量の**精度**の指標、できれば標準誤差が必要である。

そのような場合、効果量の $p$ -値から標準誤差を推定しなければならない。これは、Altman and Bland [-@altman2011obtain] による公式を用いれば、**差分**（すなわち SMD）または**比**（すなわちリスク比またはオッズ比）に基づく効果量に対して可能である。これらの公式は、 _R_ の  `se.from.p`  関数で実装されている。 

\index{dmetar Package}

```{block, type='boxdmetar'}
**"se.from.p" 関数**

\vspace{4mm}

`se.from.p` 関数は、**{dmetar}** パッケージに含まれている。**{dmetar}** がインストールされ、コンピュータに読み込まれると、この関数を使用できるようになる。もし、**{dmetar}** をインストールして**いない**場合は、以下の手順でインストールできる。

1. 関数のソースコードに [オンライン](https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/power.analysis.subgroup.R) でアクセスする。 
2. ソースコード全体をコンソール（R Studio の左下ペイン）にコピー＆ペーストし、Enterキーを押して、 _R_ に関数を「学習」させる。
```


 $N=$  71人の参加者を持つ研究で、$d=$  0.71 の効果量を報告していると仮定すると、$p=$  0.013 のように標準誤差を計算することができる。

```{r, eval=F}
library(dmetar)

se.from.p(0.71,
          p = 0.013,
          N = 71,
          effect.size.type = "difference")
```

```
##   EffectSize StandardError StandardDeviation  LLCI  ULCI
## 1       0.71         0.286             2.410 0.149 1.270
```

\vspace{2mm}

 $N=$  200人の参加者が、OR=0.91、$p=$  0.38の効果量を報告した研究については、標準誤差はこのように計算される。

```{r, message=F, warning=F, eval=F}
library(magrittr) # pipe を使う

se.from.p(0.91, p = 0.38, N = 200,
          effect.size.type = "ratio") %>% t()
```

```
##                        [,1]
## logEffectSize        -0.094
## logStandardError      0.105
## logStandardDeviation  1.498
## logLLCI              -0.302
## logULCI               0.113
## EffectSize            0.910
## LLCI                  0.739
## ULCI                  1.120
```

また、 `effect.size.type = "ratio"` の場合、自動的に **log-transformed** 効果量と標準誤差も計算する。これは、 `metagen` 関数（Chapter \@ref(pre-calculated-es)） を使う際に必要なものである。

<br></br>

## $\chi^2$ 検定

---

\index{Odds Ratio}\index{オッズ比}

統計量 $\chi^2$ をオッズ比に変換するには、  `esc_chisq`  関数を使用する（d.f. = 1と仮定する；例： $\chi^2_1$  = 8.7 ）。以下はその例である。

```{r}
esc_chisq(chisq = 7.9,        # カイ二乗値
          totaln = 100,       # 全体のサンプルサイズ
          es.type = "cox.or") # オッズ比へ変換
```

<br></br>

## 治療必要例数  {#nnt}

---

\index{Number Needed To Treat}\index{治療必要例数}

Cohen's $d$ や Hedges' $g$ のような効果量は、実用的な観点からは解釈が難しいことが多い。メタ分析で介入効果が $g=$  0.35 であることを発見したとする。このような効果が何を意味するのか、患者、公務員、医療関係者、その他の利害関係者にどのように伝えればよいのだろうか。 

また、他の人が結果を理解しやすいように、メタ分析ではしばしば**治療必要例数** (Number Needed to Treat, NNT) を報告している。この指標は、医学研究において最も一般的に使用されている。これは、1つの**ネガティブな事象**（例：再発）を**予防**するため、あるいは1つの**ポジティブ**な事象（例：症状の寛解、反応）を**達成**するために、研究対象の治療を何人の患者が追加で受けなければならないかを意味する。例えば、NNT = 3 の場合、研究課題に応じて、追加で1件の再発を回避するために3人が治療を受けなければならない、あるいは、確実に1件の症状寛解を達成するために3人の患者が治療を受けなければならないと言うことができる。

二値効果量データを扱う場合、NNT の算出は比較的容易である。式は次のようになる。

\begin{equation}
\text{NNT} = (p_{e_{\text{treat}}}-p_{e_{\text{control}}})^{-1}
(\#eq:esc6)
\end{equation}

この式で、$p_{e_{\text{treat}}}$  と $p_{e_{\text{control}}}$  は、それぞれ治療群と対照群でイベントを経験した参加者の割合である。これらの割合は、リスク比（Chapter \@ref(rr)  ）を計算するのに使われる「リスク」と同じで、**実験群イベント率**（EER）および**対照群イベント率**（CER）としても知られている。その式から、NTT は（絶対）リスク差の逆数と表現することもできる。

標準化平均差またはHedges' $g$ を NNT に変換するのはより複雑である。よく使われる方法は2つある。

\index{Area Under The Curve (AUC)}\index{曲線下面積}

* 治療群の患者が対照群の患者より好ましいアウトカムを得る確率として定義される**曲線下面積**（AUC）からNNTを計算する **Kraemer and Kupfer** [-@kraemer2006size] による方法である。この方法は、余分な情報なしに SMD または $g$  から直接 NNT を計算することができる。

* **Furukawa and Leucht** の方法は、CER またはその合理的な推定値を用いて SMD から NNT 値を計算するものである。古川氏の方法は、Kraemer &amp; Kupfer 法 [@furukawa2011obtain] と比較して、真の NNT 値を推定するのに優れていることが示されている。したがって、CER を合理的に推定できるのであれば、常に Furukawa 式が優先されるべきである。 

効果量としてリスク比やオッズ比を使用する場合、NNT は  `nnt` 関数を使用して **{meta}** オブジェクトから直接計算することができる。`metabin` （Chapter \@ref(pooling-or-rr)）を使ってメタ分析を行った後、その結果を `nnt` 関数に代入するだけである。以下はその例である。

```{r}
library(meta)
data(Olkin1995)

# 二値効果量データを使ってメタ分析を実行
m.b <- metabin(ev.exp, n.exp, ev.cont, n.cont, 
               data = Olkin1995,
               sm = "RR")
nnt(m.b)
```

\vspace{2mm}

`nnt` 関数は、異なる CER を仮定した場合の治療に必要な数を提供する。3行あるのは、このデータセットにおける最小、平均、最大の CER の結果を示している。CER の平均値は、通常報告される「典型的な」NNT である。 

また、要約指標 `sm` が `"RR"` または `"OR"` であれば、`nnt` を `metagen` モデルで使用することも可能である。このようなモデルでは、`nnt` の `p.c` 引数で想定される CER を指定する必要がある。以下は、Chapter \@ref(m-gen-bin)  で作成した `m.gen_bin`  メタ分析オブジェクトを使用した例である。

```{r, echo=F}
load("data/m.gen_bin.rda")
m.gen_bin$print.subgroup.name = FALSE

```


```{r}
# 固定効果も出るの結果も示す
m.gen_bin <- update.meta(m.gen_bin, 
                         fixed = TRUE)

nnt(m.gen_bin, 
    p.c = 0.1) # CER 0.1 を使用
```

\vspace{4mm}

\index{dmetar Package}

標準化平均差または Hedges' $g$  は、 **{dmetar}** の  `NNT`  関数を使用して NNT に変換することができる。

```{block, type='boxdmetar'}
**"NNT" 関数**

\vspace{4mm}

もし、**{dmetar}** をインストールして**いない**場合は、以下の手順でインストールできる。

\vspace{2mm}

1. 関数のソースコードに [オンライン](https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/power.analysis.subgroup.R) でアクセスする。
2. ソースコード全体をコンソール（R Studio の左下ペイン）にコピー＆ペーストし、Enterキーを押して、 _R_ に関数を「学習」させる。

```


Kraemer &amp; Kupfer 法を使うには、 `NNT` 関数に効果量（SMD または $g$  ）を与えるだけでよい。Furukawa 法は、`CER` の値が与えられるとすぐに自動的に使用される。

```{r}
NNT(d = 0.245)

NNT(d = 0.245, CER = 0.35)
```


```{block, type='boximportant'}
**注意して扱うべき数字: NNT への批判**

\vspace{2mm}

一般的ではあるが、臨床試験の結果を伝えるために NNT を使用することは議論の余地がないわけではない。批判としては、一般人がしばしば誤解すること（他の効果量の指標に代わる「直感的な」指標とされているにもかかわらず @christensen2006number）、研究者がよく NNT を不正確に計算すること [@mendes2017number] が挙げられる。

\vspace{2mm}

さらに、NNT の信頼できる標準誤差（および信頼区間）を計算することはできないので、メタアナリシスでは使用できないことになる [@hutton2010misleading]。別の効果量指標を用いてプールを行った後に初めて、結果を NNT に変換することが可能である。

```

<br></br>

## マルチアーム研究  {#pool-groups}

---

\index{Unit-of-Analysis Problem}\index{分析単位問題}

解析単位誤差（Chapter \@ref(unit-of-analysis)）を避けるために、（標準化）平均差を計算する前に、2つ以上の試験群の平均と標準偏差をプールする必要がある場合がある。2群の連続効果量データをプールするには、以下の式を用いることができる。

\begin{align}
n_{\text{pooled}} &= n_1 + n_2  \\
m_{\text{pooled}} &= \frac{n_1m_1+n_2m_2}{n_1+n_2} \\
SD_{\text{pooled}} &= \sqrt{\frac{(n_1-1)SD^{2}_{1}+ (n_2-1)SD^{2}_{2}+\frac{n_1n_2}{n_1+n_2}(m^{2}_1+m^{2}_2-2m_1m_2)} {n_1+n_2-1}}
\end{align}

この式を _R_ で適用するには、 `pool.groups` 関数を使用する。

```{block, type='boxdmetar'}
**"pool.groups" 関数**

\vspace{4mm}

`pool.groups` 関数は、**{dmetar}** パッケージに含まれている。**{dmetar}** がインストールされ、コンピュータに読み込まれると、この関数を使用できるようになる。もし、**{dmetar}** をインストールして**いない**場合は、以下の手順でインストールできる。

1. 関数のソースコードに [オンライン](https://raw.githubusercontent.com/MathiasHarrer/dmetar/master/R/power.analysis.subgroup.R) でアクセスする。
2. ソースコード全体をコンソール（R Studio の左下ペイン）にコピー＆ペーストし、Enterキーを押して、 _R_ に関数を「学習」させる。

```


以下はその一例である。

```{r}
library(dmetar)

pool.groups(n1 = 50,   # group 1 サンプルサイズ
            n2 = 50,   # group 2 サンプルサイズ
            m1 = 3.5,  # group 1 平均
            m2 = 4,    # group 2 平均
            sd1 = 3,   # group 1 標準偏差
            sd2 = 3.8) # group 2 標準偏差
```


<br></br>

## 効果量の集約  {#aggregate-es}

---

 **{metafor}** の  `aggregate`  関数を使うと、例えば、同じ研究やクラスターの一部であるという理由で、いくつかの従属する **事前に計算された効果量** を一つの推定値に集約することが可能である。これは、**unit-of-analysis error** （ Chapter \@ref(unit-of-analysis)  参照）を回避する方法であるが、研究内相関の値を仮定する必要があり、これは通常未知である。効果量依存性を扱うもう一つの（そしてしばしば望ましい）方法は、（相関）階層モデルで、これは Chapter \@ref(multilevel-ma)  で説明されている。 

この例では、 `Chernobyl` データセット（Chapter \@ref(multilevel-R)  参照）の効果量を集約し、各研究が1つの効果量のみを提供するようにする。

```{r, eval=F}
library(metafor)
library(dmetar)
data("Chernobyl")

# 'Chernobyl' データを 'escalc' オブジェクトに変換
Chernobyl <- escalc(yi = z,           # 効果量
                    sei = se.z,       # 標準誤差
                    data = Chernobyl)

# 研究レベルで効果量を集約
# 相関 rho=0.6 を仮定
Chernobyl.agg <- aggregate(Chernobyl, 
                           cluster = author,
                           rho = 0.6)

# 集約結果を表示
Chernobyl.agg[,c("author", "yi", "vi")]

```

```
##                       author     yi     vi 
## 1 Aghajanyan & Suskov (2009) 0.2415 0.0079 
## 2     Alexanin et al. (2010) 1.3659 0.0012 
## 3             Bochkov (1993) 0.2081 0.0014 
## 4      Dubrova et al. (1996) 0.3068 0.0132 
## 5      Dubrova et al. (1997) 0.4453 0.0110
## [...]
```

なお、`aggregate` は集約された効果量 `yi` とその**分散** (variance) `vi`  （標準誤差の平方根）を返す。


$$\tag*{$\blacksquare$}$$


